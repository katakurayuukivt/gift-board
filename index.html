<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gift Board Generator</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { background:#0f172a; color:#e5e7eb; }
    canvas { image-rendering: crisp-edges; image-rendering: pixelated; }
    .card { background:#0b1220; border:1px solid #23314d; border-radius:14px; }
    .slot-card { min-width: 180px; }
    .scrollbar-thin::-webkit-scrollbar { height: 10px; }
    .scrollbar-thin::-webkit-scrollbar-thumb { background:#334155; border-radius:6px; }
    .dragging { opacity: 0.6; }
    .btn { @apply px-3 py-2 rounded-md bg-indigo-600 hover:bg-indigo-500 text-white text-sm; }
    .btn-ghost { @apply px-3 py-2 rounded-md bg-slate-700 hover:bg-slate-600 text-white text-sm; }
    input[type="range"] { accent-color:#6366f1; }
    .label { @apply text-xs text-slate-300; }
  </style>
</head>
<body class="min-h-screen">
  <div class="mx-auto max-w-[1400px] p-4 space-y-4">
    <h1 class="text-2xl font-semibold">Gift Board Generator</h1>

    <!-- Top controls -->
    <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-3">
      <div class="card p-3 space-y-2">
        <div class="label">公開CSV直リンク（任意 / あればこちらが優先）</div>
        <input id="csvUrl" type="text" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2"
          placeholder="https://docs.google.com/spreadsheets/d/e/.../pub?gid=...&single=true&output=csv">
        <div class="grid grid-cols-2 gap-2">
          <div>
            <div class="label">Sheet ID（固定）</div>
            <input id="sheetId" type="text" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2">
          </div>
          <div>
            <div class="label">gid（固定）</div>
            <input id="gid" type="text" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2">
          </div>
        </div>
        <div class="label mt-2">CORSプロキシURL（既定）</div>
        <input id="proxyUrl" type="text" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2">
        <div class="flex gap-2 mt-3">
          <button id="loadBtn" class="btn">読み込む</button>
          <label class="btn-ghost cursor-pointer">
            背景画像を選ぶ
            <input id="bgFile" class="hidden" type="file" accept="image/*">
          </label>
          <label class="btn-ghost cursor-pointer">
            フォントを追加
            <input id="fontFile" class="hidden" type="file" accept=".ttf,.otf,.woff,.woff2">
          </label>
          <select id="fontSel" class="rounded bg-slate-800 border border-slate-600 px-2 py-2 text-sm">
            <option value="system-ui">system-ui</option>
          </select>
        </div>
      </div>

      <div class="card p-3 space-y-2">
        <div class="grid grid-cols-3 gap-2">
          <div>
            <div class="label">列 (COLS)</div>
            <input id="cols" type="number" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2" min="1" value="6">
          </div>
          <div>
            <div class="label">行 (ROWS)</div>
            <input id="rows" type="number" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2" min="1" value="3">
          </div>
          <div>
            <div class="label">丸角 px</div>
            <input id="radius" type="number" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2" min="0" value="18">
          </div>
        </div>
        <div class="grid grid-cols-3 gap-2">
          <div>
            <div class="label">枠幅 TILE_W</div>
            <input id="tileW" type="number" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2" min="20" value="320">
          </div>
          <div>
            <div class="label">枠高 TILE_H</div>
            <input id="tileH" type="number" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2" min="20" value="180">
          </div>
          <div>
            <div class="label">枠間 GAP</div>
            <input id="gap" type="number" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2" min="0" value="20">
          </div>
        </div>
        <div class="grid grid-cols-3 gap-2">
          <div>
            <div class="label">左上オフセットX</div>
            <input id="offX" type="number" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2" value="0">
          </div>
          <div>
            <div class="label">左上オフセットY</div>
            <input id="offY" type="number" class="w-full rounded bg-slate-800 border border-slate-600 px-2 py-2" value="0">
          </div>
          <div>
            <div class="label">ズーム</div>
            <div class="flex items-center gap-2">
              <input id="zoom" type="range" min="25" max="200" value="100" class="w-full">
              <button id="rerender" class="btn-ghost">更新</button>
            </div>
          </div>
        </div>
        <div class="flex items-center gap-3">
          <label class="flex items-center gap-2"><input id="showText" type="checkbox" class="scale-125" checked> プレビューでテキスト表示</label>
          <label class="flex items-center gap-2"><input id="includeTextInPng" type="checkbox" class="scale-125" checked> PNGにもテキストを含める</label>
          <button id="savePng" class="btn ml-auto">PNGとして保存</button>
        </div>
      </div>

      <div class="card p-3 space-y-2">
        <div class="label">ギフト一覧（クリックで追加）</div>
        <div id="giftList" class="grid grid-cols-2 gap-2 max-h-[300px] overflow-y-auto pr-1"></div>
        <div class="text-xs text-slate-400">※ 必要カラム：Gift ID / Gift Name / Gift Cost / Gift Image URL</div>
      </div>
    </div>

    <!-- Preview + placed items -->
    <div class="card p-3 space-y-3">
      <div class="flex justify-between items-center">
        <div class="text-sm text-slate-300">ライブプレビュー（幅は常に1080にスケール）</div>
        <div id="canvasNote" class="text-xs text-slate-400"></div>
      </div>
      <div class="w-full overflow-auto">
        <canvas id="cv" class="mx-auto block"></canvas>
      </div>

      <div>
        <div class="flex justify-between items-center">
          <div class="text-sm text-slate-300">配置中（ドラッグで並び替え / クリックで編集）</div>
          <button id="clearPlaced" class="btn-ghost">クリア</button>
        </div>
        <div id="placedRow" class="mt-2 flex gap-2 overflow-x-auto scrollbar-thin"></div>
      </div>

      <div id="editorPanel" class="grid gap-3"></div>
    </div>
  </div>

<script>
(() => {
  'use strict';

  // ====== State ======
  const state = {
    gifts: [],           // {id, name, cost, imgUrl}
    placed: [],          // {gift, text, iconScale, iconX, iconY, overlay?, textSize, textX, textY, textStroke, textAlign}
    bg: null,            // {img, w, h}
    userFont: null,      // {name, urlObject}
    proxy: '',
    lastCsvUrl: '',
  };

  // ====== DOM ======
  const els = {
    csvUrl: document.getElementById('csvUrl'),
    sheetId: document.getElementById('sheetId'),
    gid: document.getElementById('gid'),
    proxyUrl: document.getElementById('proxyUrl'),
    loadBtn: document.getElementById('loadBtn'),
    bgFile: document.getElementById('bgFile'),
    fontFile: document.getElementById('fontFile'),
    fontSel: document.getElementById('fontSel'),
    cols: document.getElementById('cols'),
    rows: document.getElementById('rows'),
    tileW: document.getElementById('tileW'),
    tileH: document.getElementById('tileH'),
    gap: document.getElementById('gap'),
    radius: document.getElementById('radius'),
    offX: document.getElementById('offX'),
    offY: document.getElementById('offY'),
    zoom: document.getElementById('zoom'),
    showText: document.getElementById('showText'),
    includeTextInPng: document.getElementById('includeTextInPng'),
    rerender: document.getElementById('rerender'),
    savePng: document.getElementById('savePng'),
    canvas: document.getElementById('cv'),
    canvasNote: document.getElementById('canvasNote'),
    giftList: document.getElementById('giftList'),
    placedRow: document.getElementById('placedRow'),
    editorPanel: document.getElementById('editorPanel'),
    clearPlaced: document.getElementById('clearPlaced'),
  };

  // ====== Defaults ======
  const DEFAULT_SHEET_ID = '15QtBjbdETvUNL64JF46MvTvkfXaZI_jAtTphKQH6Y5U';
  const DEFAULT_GID = '1487601753';
  const DEFAULT_PROXY = 'https://blue-field-b0dc.katakura-yuuki-1121.workers.dev';

  els.sheetId.value = DEFAULT_SHEET_ID;
  els.gid.value = DEFAULT_GID;
  els.proxyUrl.value = DEFAULT_PROXY;
  state.proxy = DEFAULT_PROXY;

  // Prefill CSV URL using Sheet ID/gid if empty (published CSV形式)
  function buildCsvUrl(sheetId, gid) {
    return `https://docs.google.com/spreadsheets/d/${encodeURIComponent(sheetId)}/export?format=csv&gid=${encodeURIComponent(gid)}`;
  }
  els.csvUrl.placeholder = buildCsvUrl(DEFAULT_SHEET_ID, DEFAULT_GID);

  // ====== Utils ======
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function parseCSV(text) {
    // Minimal CSV parser that handles quoted fields and commas/newlines
    const rows = [];
    let i = 0, cell = '', row = [], inQ = false;
    while (i < text.length) {
      const ch = text[i];
      if (inQ) {
        if (ch === '"') {
          if (text[i+1] === '"') { cell += '"'; i += 2; }
          else { inQ = false; i++; }
        } else { cell += ch; i++; }
      } else {
        if (ch === '"') { inQ = true; i++; }
        else if (ch === ',') { row.push(cell); cell=''; i++; }
        else if (ch === '\n') { row.push(cell); rows.push(row); cell=''; row=[]; i++; }
        else if (ch === '\r') { i++; }
        else { cell += ch; i++; }
      }
    }
    row.push(cell); rows.push(row);
    return rows;
  }

  function extractHyperlink(v) {
    const s = String(v || '');
    if (!s.startsWith('=HYPERLINK(')) return s;
    const first = s.indexOf('"');
    if (first < 0) return s;
    const second = s.indexOf('"', first + 1);
    if (second < 0) return s;
    return s.slice(first + 1, second);
  }

  function h(tag, attrs = {}, ...children) {
    const el = document.createElement(tag);
    for (const [k, v] of Object.entries(attrs)) {
      if (k === 'class') el.className = v;
      else if (k === 'text') el.textContent = v;
      else if (k.startsWith('on') && typeof v === 'function') el.addEventListener(k.slice(2), v);
      else el.setAttribute(k, v);
    }
    for (const c of children) {
      if (c == null) continue;
      el.appendChild(typeof c === 'string' ? document.createTextNode(c) : c);
    }
    return el;
  }

  // Image cache via proxy
  const imgCache = new Map();
  async function fetchImageViaProxy(url) {
    const tryUrls = [];
    const px = (state.proxy || '').replace(/\/+$/,'');
    if (px) {
      tryUrls.push(`${px}?url=${encodeURIComponent(url)}`);
      tryUrls.push(`${px}/raw?url=${encodeURIComponent(url)}`);
      tryUrls.push(`${px}/${encodeURIComponent(url)}`);
    }
    tryUrls.push(url); // try direct last

    let lastErr;
    for (const u of tryUrls) {
      try {
        const res = await fetch(u, { mode: 'cors' });
        if (!res.ok) throw new Error('HTTP '+res.status);
        const blob = await res.blob();
        return URL.createObjectURL(blob);
      } catch (e) {
        lastErr = e;
      }
    }
    throw lastErr || new Error('fetch failed');
  }

  async function getImage(url) {
    if (imgCache.has(url)) return imgCache.get(url);
    const p = (async () => {
      const objUrl = await fetchImageViaProxy(url);
      const img = new Image();
      img.src = objUrl;
      await img.decode();
      return img;
    })();
    imgCache.set(url, p);
    return p;
  }

  // ====== Gifts loading ======
  async function loadSheet() {
    const csvLink = (els.csvUrl.value || '').trim();
    const sid = (els.sheetId.value || '').trim();
    const gid = (els.gid.value || '').trim();
    state.proxy = (els.proxyUrl.value || '').trim();
    const url = csvLink || buildCsvUrl(sid, gid);
    state.lastCsvUrl = url;
    try {
      const prox = `${state.proxy.replace(/\/+$/,'')}?url=${encodeURIComponent(url)}`;
      const res = await fetch(prox, { mode:'cors' });
      if (!res.ok) throw new Error('HTTP '+res.status);
      const txt = await res.text();
      const rows = parseCSV(txt);
      const header = rows[0].map(s => s.trim().toLowerCase());
      const idx = {
        id: header.findIndex(h => h.includes('gift id') || h === 'id'),
        name: header.findIndex(h => h.includes('gift name') || h === 'name'),
        cost: header.findIndex(h => h.includes('gift cost') || h === 'cost' || h.includes('coin')),
        img: header.findIndex(h => h.includes('image')),
      };
      const gifts = [];
      for (let r = 1; r < rows.length; r++) {
        const row = rows[r];
        if (!row.length) continue;
        const id = row[idx.id]?.trim();
        const name = row[idx.name]?.trim();
        const cost = Number(row[idx.cost] || 0) || 0;
        let imgUrl = extractHyperlink(row[idx.img]);
        if (!imgUrl) continue;
        gifts.push({ id, name, cost, imgUrl });
      }
      state.gifts = gifts;
      renderGiftList();
      // Reset placed
      state.placed = [];
      renderPlacedRow();
      render();
    } catch (e) {
      console.error(e);
      alert('シート取得に失敗（CORS/権限/URL）');
    }
  }

  function renderGiftList() {
    els.giftList.innerHTML = '';
    for (const g of state.gifts) {
      const btn = h('button', { class: 'w-full text-left px-3 py-2 rounded bg-slate-800 hover:bg-slate-700 border border-slate-600' });
      btn.append(
        h('div', { class:'text-sm font-medium', text: g.name || '(no name)' }),
        h('div', { class:'text-xs text-slate-400', text: `${g.cost ?? 0} coin` }),
      );
      btn.addEventListener('click', () => {
        state.placed.push({
          gift: g,
          text: '',
          iconScale: 100,
          iconX: 0,
          iconY: 0,
          overlay: null, // {img, scale, x, y, opacity}
          textSize: 72,
          textX: 0,
          textY: 0,
          textStroke: true,
          textAlign: 'center',
        });
        renderPlacedRow();
        render();
      });
      els.giftList.appendChild(btn);
    }
  }

  // ====== Placed row (cards) ======
  function renderPlacedRow() {
    els.placedRow.innerHTML = '';
    state.placed.forEach((p, idx) => {
      const card = h('div', { class:'slot-card card p-2 flex flex-col cursor-grab', draggable:'true' });
      card.dataset.index = String(idx);
      card.append(
        h('div', { class:'text-[11px] text-slate-400', text: `#${idx+1}` }),
        h('div', { class:'text-sm font-medium truncate', text: p.gift.name || '(no name)' }),
        h('div', { class:'text-xs text-slate-500', text: `${p.gift.cost ?? 0} coin` }),
        h('button', { class:'mt-2 btn-ghost', text:'編集', onclick: () => openEditor(idx) }),
      );
      // drag events
      card.addEventListener('dragstart', (e) => {
        card.classList.add('dragging');
        e.dataTransfer.setData('text/plain', String(idx));
      });
      card.addEventListener('dragend', () => card.classList.remove('dragging'));
      card.addEventListener('dragover', (e) => {
        e.preventDefault();
        const from = Number(e.dataTransfer.getData('text/plain'));
        const to = Number(card.dataset.index);
        if (!Number.isInteger(from) || !Number.isInteger(to) || from === to) return;
        const itm = state.placed.splice(from, 1)[0];
        state.placed.splice(to, 0, itm);
        renderPlacedRow();
        render();
      });
      els.placedRow.appendChild(card);
    });
  }

  function openEditor(index) {
    const p = state.placed[index];
    if (!p) return;
    els.editorPanel.innerHTML = '';
    const panel = h('div', { class:'card p-3 space-y-2' });
    panel.append(h('div', { class:'text-sm text-slate-300' , text:`スロット編集 #${index+1}（${p.gift.name}）` }));

    // text
    panel.append(h('div', { class:'label', text:'スロットテキスト'}));
    const tx = h('input', { type:'text', value:p.text, class:'w-full rounded bg-slate-800 border border-slate-600 px-2 py-2'});
    tx.addEventListener('input', () => { p.text = tx.value; render(); });
    panel.append(tx);

    // icon controls
    const row1 = h('div', { class:'grid grid-cols-4 gap-2' });
    const scale = h('input', { type:'number', value:p.iconScale, class:'rounded bg-slate-800 border border-slate-600 px-2 py-2' });
    const ix = h('input', { type:'number', value:p.iconX, class:'rounded bg-slate-800 border border-slate-600 px-2 py-2' });
    const iy = h('input', { type:'number', value:p.iconY, class:'rounded bg-slate-800 border border-slate-600 px-2 py-2' });
    const del = h('button', { class:'btn-ghost', text:'削除' });
    row1.append(
      h('div', {}, h('div',{class:'label',text:'アイコン倍率 %'},), scale),
      h('div', {}, h('div',{class:'label',text:'アイコンX'},), ix),
      h('div', {}, h('div',{class:'label',text:'アイコンY'},), iy),
      del
    );
    scale.addEventListener('input', () => { p.iconScale = Number(scale.value)||0; render(); });
    ix.addEventListener('input', () => { p.iconX = Number(ix.value)||0; render(); });
    iy.addEventListener('input', () => { p.iconY = Number(iy.value)||0; render(); });
    del.addEventListener('click', () => {
      state.placed.splice(index,1);
      els.editorPanel.innerHTML = '';
      renderPlacedRow();
      render();
    });
    panel.append(row1);

    // overlay
    const ovRow = h('div', { class:'grid grid-cols-5 gap-2 items-end'});
    const ovLabel = h('div', { class:'label col-span-5', text:'追加画像（任意）'});
    const file = h('input', { type:'file', accept:'image/*', class:'col-span-2' });
    const ovScale = h('input', { type:'number', value: p.overlay?.scale ?? 100, class:'rounded bg-slate-800 border border-slate-600 px-2 py-2'});
    const ovX = h('input', { type:'number', value: p.overlay?.x ?? 0, class:'rounded bg-slate-800 border border-slate-600 px-2 py-2'});
    const ovY = h('input', { type:'number', value: p.overlay?.y ?? 0, class:'rounded bg-slate-800 border border-slate-600 px-2 py-2'});
    const ovOp = h('input', { type:'number', value: p.overlay?.opacity ?? 100, class:'rounded bg-slate-800 border border-slate-600 px-2 py-2'});
    panel.append(ovLabel);
    ovRow.append(
      file,
      h('div',{}, h('div',{class:'label',text:'倍率 %'}), ovScale),
      h('div',{}, h('div',{class:'label',text:'X'},), ovX),
      h('div',{}, h('div',{class:'label',text:'Y'},), ovY),
      h('div',{}, h('div',{class:'label',text:'不透明 %'},), ovOp),
    );
    panel.append(ovRow);
    file.addEventListener('change', async () => {
      const f = file.files?.[0];
      if (!f) { p.overlay = null; render(); return; }
      const url = URL.createObjectURL(f);
      const img = new Image(); img.src = url; await img.decode();
      p.overlay = { img, scale: Number(ovScale.value)||100, x:Number(ovX.value)||0, y:Number(ovY.value)||0, opacity:Number(ovOp.value)||100 };
      render();
    });
    for (const [el, key] of [[ovScale,'scale'], [ovX,'x'], [ovY,'y'], [ovOp,'opacity']]) {
      el.addEventListener('input', () => {
        if (!p.overlay) p.overlay = { img:null, scale:100, x:0, y:0, opacity:100 };
        p.overlay[key] = Number(el.value)||0;
        render();
      });
    }

    // Text controls
    const txtGrid = h('div', { class:'grid grid-cols-4 gap-2' });
    const tSize = h('input', { type:'number', value:p.textSize, class:'rounded bg-slate-800 border border-slate-600 px-2 py-2'});
    const tX = h('input', { type:'number', value:p.textX, class:'rounded bg-slate-800 border border-slate-600 px-2 py-2'});
    const tY = h('input', { type:'number', value:p.textY, class:'rounded bg-slate-800 border border-slate-600 px-2 py-2'});
    const tStroke = h('label', { class:'flex items-center gap-2' },
        h('input', { type:'checkbox', checked: p.textStroke ? 'checked': null }), h('span', {text:'縁'}));
    const tAlign = h('select', { class:'rounded bg-slate-800 border border-slate-600 px-2 py-2'},
        h('option', {value:'left', text:'左'}),
        h('option', {value:'center', text:'中央'}),
        h('option', {value:'right', text:'右'})
    );
    tAlign.value = p.textAlign || 'center';
    txtGrid.append(
      h('div',{}, h('div',{class:'label',text:'文字サイズ px'}), tSize),
      h('div',{}, h('div',{class:'label',text:'文字X'},), tX),
      h('div',{}, h('div',{class:'label',text:'文字Y'},), tY),
      h('div',{}, h('div',{class:'label',text:'位置'},), tAlign),
    );
    panel.append(txtGrid);
    tSize.addEventListener('input', () => { p.textSize = Number(tSize.value)||0; render(); });
    tX.addEventListener('input', () => { p.textX = Number(tX.value)||0; render(); });
    tY.addEventListener('input', () => { p.textY = Number(tY.value)||0; render(); });
    tStroke.querySelector('input').addEventListener('change', (e) => { p.textStroke = e.target.checked; render(); });
    tAlign.addEventListener('change', () => { p.textAlign = tAlign.value; render(); });

    els.editorPanel.appendChild(panel);
  }

  // ====== Rendering ======
  function roundedRect(ctx, x, y, w, h, r) {
    const rr = Math.min(r, Math.floor(Math.min(w,h)/2));
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function getDims() {
    const cols = Number(els.cols.value) || 6;
    const rows = Number(els.rows.value) || 3;
    const W = Number(els.tileW.value) || 320;
    const H = Number(els.tileH.value) || 180;
    const GAP = Number(els.gap.value) || 20;
    const r = Number(els.radius.value) || 18;
    const offX = Number(els.offX.value) || 0;
    const offY = Number(els.offY.value) || 0;
    const boardW = cols*W + (cols-1)*GAP + offX*2;
    const boardH = rows*H + (rows-1)*GAP + offY*2;
    return { cols, rows, W, H, GAP, r, offX, offY, boardW, boardH };
  }

  function layoutForIndex(idx, dims) {
    const { cols, W, H, GAP, offX, offY } = dims;
    const c = idx % cols;
    const r = Math.floor(idx / cols);
    const x = offX + c*(W + GAP);
    const y = offY + r*(H + GAP);
    return { x, y };
  }

  function applyZoomCSS(boardW) {
    const cv = els.canvas;
    const zoom = (Number(els.zoom.value)||100) / 100;
    const displayW = Math.round(1080 * zoom);
    cv.style.width = displayW + 'px';
    els.canvasNote.textContent = `表示幅: ${displayW}px / 基準 1080px`;
  }

  async function render(toBlobForSave=false) {
    const dims = getDims();
    // Canvas pixel size keeps aspect; we always scale width to 1080 for preview; internal pixel uses boardW/boardH ratio
    const scaleTo1080 = 1080 / dims.boardW;
    const cv = els.canvas;
    // internal pixel size: base on board dims but scaled so width is exactly 1080 for sharp export preview
    const internalW = Math.round(dims.boardW * scaleTo1080);
    const internalH = Math.round(dims.boardH * scaleTo1080);
    cv.width = internalW;
    cv.height = internalH;
    applyZoomCSS(dims.boardW); // CSS width
    const ctx = cv.getContext('2d');
    ctx.setTransform(scaleTo1080, 0, 0, scaleTo1080, 0, 0); // draw in board coordinates

    // Background
    ctx.clearRect(0,0,dims.boardW,dims.boardH);
    if (state.bg?.img) {
      // cover
      const bg = state.bg.img;
      const s = Math.max(dims.boardW/bg.width, dims.boardH/bg.height);
      const dw = bg.width * s;
      const dh = bg.height * s;
      const dx = (dims.boardW - dw)/2;
      const dy = (dims.boardH - dh)/2;
      ctx.drawImage(bg, dx, dy, dw, dh);
    } else {
      ctx.fillStyle = '#0f172a';
      ctx.fillRect(0,0,dims.boardW,dims.boardH);
    }

    // Grid
    for (let r=0; r<dims.rows; r++) {
      for (let c=0; c<dims.cols; c++) {
        const x = dims.offX + c*(dims.W + dims.GAP);
        const y = dims.offY + r*(dims.H + dims.GAP);
        ctx.save();
        ctx.globalAlpha = 0.9;
        roundedRect(ctx, x, y, dims.W, dims.H, dims.r);
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(116,132,168,0.45)';
        ctx.stroke();
        ctx.restore();
      }
    }

    // Items
    for (let i=0; i<state.placed.length; i++) {
      const p = state.placed[i];
      const cell = layoutForIndex(i, dims);
      // Icon
      try {
        const img = await getImage(p.gift.imgUrl);
        const baseW = dims.W; // scale relative to tile width
        const scale = (p.iconScale || 100) / 100;
        const iw = Math.min(img.width, img.height);
        const ratio = img.height / img.width;
        const drawW = baseW * 0.75 * scale;
        const drawH = drawW * ratio;
        const cx = cell.x + dims.W/2 + (p.iconX||0);
        const cy = cell.y + dims.H/2 + (p.iconY||0);
        ctx.drawImage(img, cx - drawW/2, cy - drawH/2, drawW, drawH);
      } catch (e) {
        // ignore
      }

      // Overlay
      if (p.overlay?.img) {
        const baseW = dims.W;
        const s = (p.overlay.scale || 100) / 100;
        const dw = baseW * 0.75 * s;
        const ratio = p.overlay.img.height / p.overlay.img.width;
        const dh = dw * ratio;
        const cx = cell.x + dims.W/2 + (p.overlay.x||0);
        const cy = cell.y + dims.H/2 + (p.overlay.y||0);
        ctx.save();
        ctx.globalAlpha = (p.overlay.opacity || 100)/100;
        ctx.drawImage(p.overlay.img, cx - dw/2, cy - dh/2, dw, dh);
        ctx.restore();
      }

      // Text
      if (els.showText.checked || (toBlobForSave && els.includeTextInPng.checked)) {
        const t = (p.text || '').trim();
        if (t) {
          const cx = cell.x + dims.W/2 + (p.textX||0);
          const cy = cell.y + dims.H/2 + (p.textY||0);
          const size = p.textSize || 72;
          const fontName = state.userFont?.name || 'system-ui';
          ctx.save();
          ctx.font = `bold ${size}px "${fontName}"`;
          ctx.textAlign = p.textAlign || 'center';
          ctx.textBaseline = 'middle';
          if (p.textStroke) {
            ctx.lineWidth = Math.max(4, Math.floor(size/10));
            ctx.strokeStyle = 'rgba(0,0,0,0.9)';
            ctx.strokeText(t, cx, cy);
          }
          ctx.fillStyle = '#ffffff';
          ctx.fillText(t, cx, cy);
          ctx.restore();
        }
      }
    }
  }

  // ====== Events ======
  els.loadBtn.addEventListener('click', loadSheet);
  els.proxyUrl.addEventListener('change', () => { state.proxy = els.proxyUrl.value.trim(); imgCache.clear(); });
  els.bgFile.addEventListener('change', async () => {
    const f = els.bgFile.files?.[0];
    if (!f) { state.bg = null; render(); return; }
    const url = URL.createObjectURL(f);
    const img = new Image(); img.src = url; await img.decode();
    state.bg = { img, w: img.width, h: img.height };
    render();
  });
  els.fontFile.addEventListener('change', async () => {
    const f = els.fontFile.files?.[0];
    if (!f) return;
    const url = URL.createObjectURL(f);
    const name = f.name.replace(/\.(ttf|otf|woff2?|TTF|OTF|WOFF2?)$/,'');
    const ff = new FontFace(name, `url(${url})`);
    await ff.load();
    document.fonts.add(ff);
    state.userFont = { name, urlObject: url };
    const opt = document.createElement('option');
    opt.value = name; opt.textContent = name;
    els.fontSel.appendChild(opt);
    els.fontSel.value = name;
    render();
  });
  els.fontSel.addEventListener('change', () => {
    const v = els.fontSel.value;
    if (v === 'system-ui') state.userFont = null;
    else state.userFont = { name: v };
    render();
  });

  for (const id of ['cols','rows','tileW','tileH','gap','radius','offX','offY','zoom','showText','includeTextInPng']) {
    els[id].addEventListener('input', () => render());
  }
  els.rerender.addEventListener('click', () => render());

  els.savePng.addEventListener('click', async () => {
    await render(true);
    els.canvas.toBlob((blob) => {
      if (!blob) return;
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'gift_board.png';
      a.click();
      URL.revokeObjectURL(a.href);
    });
  });

  els.clearPlaced.addEventListener('click', () => {
    state.placed = [];
    renderPlacedRow();
    els.editorPanel.innerHTML = '';
    render();
  });

  // ====== Init ======
  // Try auto-load with defaults on first open (best effort)
  (async () => {
    try {
      await loadSheet();
    } catch {}
    render();
  })();
})();
</script>
</body>
</html>
