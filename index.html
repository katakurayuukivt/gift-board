<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Gift Board Generator</title>
<link rel="icon" href="data:,">
<style>
:root{--bg:#0e1218;--card:#161b24;--muted:#94a3b8;--accent:#60a5fa;--edge:#263044;}
*{box-sizing:border-box}
html,body{height:100%}
body{margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Noto Sans JP","Hiragino Kaku Gothic ProN","Yu Gothic",sans-serif}
button,input,select{font:inherit}
.container{display:grid;grid-template-columns:1fr 360px;gap:16px;padding:16px}
@media (max-width:1100px){.container{grid-template-columns:1fr}}
.panel{background:var(--card);border:1px solid var(--edge);border-radius:14px;padding:12px}
.row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
.row .grow{flex:1}
label{font-size:12px;color:var(--muted)}
input[type="text"],input[type="number"],select{width:100%;background:#0b0f15;color:#fff;border:1px solid #2a3140;border-radius:8px;padding:8px 10px;min-width:0}
button{background:#243246;border:1px solid #2a3140;color:#e5e7eb;padding:10px 14px;border-radius:10px;cursor:pointer}
button.primary{background:var(--accent);color:#0b1020;border:none;font-weight:700}
button.ghost{background:transparent;border-color:#334155}
.btnsm{padding:6px 10px;border-radius:8px}
.title{font-weight:800;margin:2px 0 10px;font-size:16px}
.note{font-size:12px;color:var(--muted)}
hr{border:none;border-top:1px solid #1f2937;margin:12px 0}
/* gift list */
.list{display:grid;grid-template-columns:1fr 1fr;gap:8px;max-height:64vh;overflow:auto}
.item{background:#0f1623;border:1px solid #2f3a4f;padding:12px;border-radius:12px;text-align:left}
.item .name{font-weight:800}
.item .muted{color:#cbd5e1;font-size:13px;margin-top:4px}
/* slots */
.slots{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
.slot{background:#121722;border:1px solid #2e3747;border-radius:14px;padding:10px}
.cap{font-size:12px;color:var(--muted);margin-bottom:6px}
.name{font-weight:800;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.compact{display:flex;align-items:center;gap:10px;justify-content:space-between}
.badge{font-size:12px;color:#cbd5e1;margin-left:6px}
.ctrl{display:grid;grid-template-columns:repeat(2,1fr);gap:8px;margin-top:8px}
.ctrl3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:8px}
.rowmid{display:flex;gap:8px;align-items:center}
.rem{color:#f87171;cursor:pointer;font-size:12px}
/* canvas area */
.canvaswrap{position:relative;background:#0b0f15;border:1px solid #2a3140;border-radius:12px;height:520px;display:flex;align-items:center;justify-content:center;overflow:hidden}
canvas{max-width:100%;max-height:100%}
.ctrlbar{display:flex;align-items:center;gap:10px}
.range{width:220px}
.small{font-size:12px;color:#cbd5e1}
</style>
</head>
<body>
<div class="container">

  <section class="panel">
    <div class="title">ライブプレビュー</div>

    <div class="row">
      <div class="grow">
        <label>Sheet ID / gid（固定）</label>
        <div class="row">
          <input id="sheetId" class="grow" type="text" readonly>
          <input id="gid" style="width:130px" type="text" readonly>
        </div>
      </div>
      <div>
        <label>（任意）CORSプロキシURL</label>
        <input id="proxy" type="text" value="https://api.allorigins.win/raw?url=" placeholder="https://your-proxy.example.com/?url=">
      </div>
      <div style="align-self:end"><button id="loadBtn" class="primary">読み込む</button></div>
      <div style="align-self:end"><button id="bgBtn">背景画像を選ぶ</button><input id="bgFile" type="file" accept="image/*" style="display:none"></div>

      <div style="align-self:end">
        <button id="fontBtn">フォントを選ぶ</button>
        <input id="fontFile" type="file" accept=".ttf,.otf,.woff,.woff2" style="display:none">
        <div class="small">使用中: <span id="fontName">System UI</span></div>
      </div>

      <div style="align-self:end" class="rowmid">
        <label><input id="exportText" type="checkbox" checked> PNGにテキストを含める</label>
      </div>
      <div style="align-self:end"><button id="saveBtn" class="primary">PNGとして保存</button></div>
    </div>

    <hr>

    <div class="row">
      <div><label>列 (COLS)</label><input id="cols" type="number" min="1" value="6"></div>
      <div><label>行 (ROWS)</label><input id="rows" type="number" min="1" value="3"></div>
      <div><label>枠幅 TILE_W</label><input id="tileW" type="number" min="40" value="320"></div>
      <div><label>枠高 TILE_H</label><input id="tileH" type="number" min="40" value="180"></div>
      <div><label>枠間 GAP</label><input id="gap" type="number" min="0" value="20"></div>
      <div><label>丸角 px</label><input id="radius" type="number" min="0" value="18"></div>
      <div><label>ガイド枠描画</label><select id="guide"><option>ON</option><option>OFF</option></select></div>
    </div>

    <div class="row" style="margin-top:8px">
      <div class="grow"><label>（任意）全体テキスト（未入力なら各スロットのテキストのみ）</label><input id="globalText" type="text" placeholder=""></div>
      <div><label>文字サイズ px（既定）</label><input id="fontSize" type="number" value="86"></div>
      <div><label>色（既定）</label><input id="fontColor" type="color" value="#ffffff"></div>
      <div class="rowmid"><label><input id="fontStroke" type="checkbox" checked> 縁（既定）</label></div>
      <div><label>横位置（既定）</label>
        <select id="textAlign"><option value="center">中央</option><option value="left">左</option><option value="right">右</option></select>
      </div>
      <div><label>縦位置（既定）</label>
        <select id="textVAlign"><option value="middle">中央</option><option value="top">上</option><option value="bottom">下</option></select>
      </div>
      <div><label>文字オフX（既定）</label><input id="textOffX" type="number" value="0"></div>
      <div><label>文字オフY（既定）</label><input id="textOffY" type="number" value="0"></div>
    </div>

    <div class="canvaswrap" id="canvasWrap">
      <canvas id="preview" width="1080" height="608"></canvas>
    </div>

    <div class="row ctrlbar" style="margin-top:10px">
      <span class="small">ズーム</span>
      <input id="zoom" class="range" type="range" min="50" max="200" value="100">
      <span class="small" id="zoomVal">100%</span>
      <button id="updateBtn" class="btnsm">更新</button>
      <span class="note">※ 生成PNGはテキストも含めます（チェックで切替可）。</span>
    </div>

  </section>

  <aside class="panel">
    <div class="title">ギフト一覧（クリックで追加）</div>
    <div id="list" class="list"></div>
    <div class="row" style="margin-top:8px"><button id="clearBtn" class="ghost btnsm">クリア</button></div>
    <hr>
    <div class="title">配置中（行×列）</div>
    <div id="slots" class="slots"></div>
  </aside>

</div>

<script>
(() => {
  // ======= Const & State =======
  const DEFAULT_PROXY = "https://api.allorigins.win/raw?url=";
  const FIXED_SHEET_ID = "15QtBjbdETvUNL64JF46MvTvkfXaZI_jAtTphKQH6Y5U";
  const FIXED_GID = "1487601753";

  const S = {
    gifts: [],
    slots: [],
    bgBitmap: null,
    canvasW: 1080,
    canvasH: 608,
    fontFamily: null // uploaded font family name (null => system-ui)
  };

  // ======= DOM =======
  const elSheetId = document.getElementById('sheetId');
  const elGid = document.getElementById('gid');
  const elProxy = document.getElementById('proxy');
  const elList = document.getElementById('list');
  const elSlots = document.getElementById('slots');
  const elPreview = document.getElementById('preview');
  const ctx = elPreview.getContext('2d', {alpha:false});

  const elCols = document.getElementById('cols');
  const elRows = document.getElementById('rows');
  const elTileW = document.getElementById('tileW');
  const elTileH = document.getElementById('tileH');
  const elGap   = document.getElementById('gap');
  const elRadius= document.getElementById('radius');
  const elGuide = document.getElementById('guide');

  const elGlobalText = document.getElementById('globalText');
  const elFontSize = document.getElementById('fontSize');
  const elFontColor = document.getElementById('fontColor');
  const elFontStroke = document.getElementById('fontStroke');
  const elTextAlign = document.getElementById('textAlign');
  const elTextVAlign = document.getElementById('textVAlign');
  const elTextOffX = document.getElementById('textOffX');
  const elTextOffY = document.getElementById('textOffY');
  const elExportText = document.getElementById('exportText');

  const elZoom = document.getElementById('zoom');
  const elZoomVal = document.getElementById('zoomVal');
  const elFontBtn = document.getElementById('fontBtn');
  const elFontFile = document.getElementById('fontFile');
  const elFontName = document.getElementById('fontName');

  // Buttons
  document.getElementById('loadBtn').onclick = onLoadSheet;
  document.getElementById('clearBtn').onclick = () => { S.slots=[]; renderSlots(); draw(); };
  document.getElementById('updateBtn').onclick = () => draw();
  document.getElementById('saveBtn').onclick = () => exportPNG();
  document.getElementById('bgBtn').onclick = () => document.getElementById('bgFile').click();
  document.getElementById('bgFile').onchange = onPickBg;
  elFontBtn.onclick = () => elFontFile.click();
  elFontFile.onchange = onPickFont;

  // fixed IDs
  elSheetId.value = FIXED_SHEET_ID;
  elGid.value = FIXED_GID;
  if (!elProxy.value) elProxy.value = DEFAULT_PROXY;

  // zoom
  elZoom.oninput = () => {
    const v = Number(elZoom.value);
    elZoomVal.textContent = v + '%';
    const wrap = document.getElementById('canvasWrap');
    wrap.style.transform = 'scale(' + (v/100) + ')';
    wrap.style.transformOrigin = 'left top';
  };

  // ======= Utilities =======
  function csvToRows(csvText){
    const rows=[]; let i=0, cell='', row=[], inQ=false;
    while(i<csvText.length){
      const ch = csvText[i];
      if(inQ){
        if(ch === '"'){
          if(csvText[i+1] === '"'){ cell+='"'; i+=2; }
          else { inQ=false; i++; }
        } else { cell += ch; i++; }
      }else{
        if(ch === '"'){ inQ = true; i++; }
        else if(ch === ','){ row.push(cell); cell=''; i++; }
        else if(ch === '\n'){ row.push(cell); rows.push(row); cell=''; row=[]; i++; }
        else if(ch === '\r'){ i++; }
        else { cell += ch; i++; }
      }
    }
    if(cell!=='' || row.length){ row.push(cell); rows.push(row); }
    return rows;
  }
  function extractHyperlink(s){
    if(!s) return s;
    const t = String(s).trim();
    if(!t.startsWith('=HYPERLINK(')) return t;
    const first = t.indexOf('"');
    if(first < 0) return t;
    const second = t.indexOf('"', first + 1);
    if(second < 0) return t;
    return t.slice(first + 1, second);
  }
  async function fetchImageBlobWithFallback(rawUrl){
    if(!rawUrl) throw new Error('no url');
    let u = null;
    try{
      const s = String(rawUrl).trim().replace(/^\/\//,'https://');
      u = new URL(s);
    }catch{}
    const encHostPath = u ? (u.host + encodeURI(u.pathname) + (u.search||'')) : null;
    const user = (elProxy.value || DEFAULT_PROXY).trim();
    const cands = [];
    if(user){
      if(user.includes('url=')) cands.push(user + encodeURIComponent(rawUrl));
      else cands.push(user + rawUrl);
    }
    if(encHostPath){
      cands.push('https://images.weserv.nl/?url=' + encHostPath + '&output=png');
      cands.push('https://wsrv.nl/?url=' + encHostPath + '&output=png');
    }
    cands.push('https://thingproxy.freeboard.io/fetch/' + rawUrl);
    cands.push(rawUrl);
    for(const url of cands){
      try{
        const res = await fetch(url, {cache:'no-store'});
        if(!res.ok) continue;
        const blob = await res.blob();
        if((blob.type||'').startsWith('image/')) return blob;
      }catch(e){}
    }
    throw new Error('画像取得の全てに失敗');
  }
  async function blobToBitmap(blob){
    if('createImageBitmap' in window) return await createImageBitmap(blob);
    return await new Promise((res,rej)=>{
      const img = new Image();
      const url = URL.createObjectURL(blob);
      img.onload = () => { URL.revokeObjectURL(url); res(img); };
      img.onerror = rej;
      img.src = url;
    });
  }
  function gridSize(){
    const COLS = Number(elCols.value), ROWS=Number(elRows.value);
    const W = Number(elTileW.value), H=Number(elTileH.value), G=Number(elGap.value);
    return {cols:COLS,rows:ROWS,tileW:W,tileH:H,gap:G,width:COLS*W+(COLS+1)*G,height:ROWS*H+(ROWS+1)*G};
  }
  function centerOffset(canvasW, canvasH, gridW, gridH){
    return { x: Math.round((canvasW-gridW)/2), y: Math.round((canvasH-gridH)/2) };
  }
  function rr(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
  function currentFontCSS(sizePx){
    const fam = S.fontFamily ? '\"'+S.fontFamily+'\", system-ui' : 'system-ui';
    return 'bold ' + sizePx + 'px ' + fam;
  }
  function drawSlotText(ctx, slot, x, y, g){
    const t = (slot.text || elGlobalText.value || '').trim();
    if(!t) return;
    const size = slot.textSize || Number(elFontSize.value||86);
    ctx.font = currentFontCSS(size);
    ctx.textAlign = slot.textAlign || elTextAlign.value;
    const vAlign = slot.textVAlign || elTextVAlign.value;
    ctx.textBaseline = (vAlign==='top'?'top':(vAlign==='bottom'?'bottom':'middle'));
    const tx = x + g.tileW/2 + (slot.textOffX||0);
    const ty = y + (vAlign==='top'?12:(vAlign==='bottom'?g.tileH-12:g.tileH/2)) + (slot.textOffY||0);
    if(slot.textStroke || elFontStroke.checked){
      ctx.lineJoin='round'; ctx.lineWidth=Math.max(4, Math.floor(size*0.12));
      ctx.strokeStyle='rgba(0,0,0,0.85)';
      ctx.strokeText(t, tx, ty);
    }
    ctx.fillStyle = slot.textColor || elFontColor.value || '#fff';
    ctx.fillText(t, tx, ty);
  }

  // ======= Font Upload =======
  async function onPickFont(e){
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    try{
      const ab = await f.arrayBuffer();
      const blob = new Blob([ab], {type: f.type || 'font/ttf'});
      const url = URL.createObjectURL(blob);
      const family = 'UserFont_' + Date.now();
      const ff = new FontFace(family, 'url('+url+')');
      await ff.load();
      document.fonts.add(ff);
      S.fontFamily = family;
      elFontName.textContent = f.name;
      URL.revokeObjectURL(url);
      draw();
    }catch(err){
      console.error(err);
      alert('フォントの読み込みに失敗しました。別のファイルをお試しください。');
    }
  }

  // ======= Sheet Load =======
  async function onLoadSheet(){
    try{
      const gifts = await loadSheet(FIXED_SHEET_ID, FIXED_GID);
      S.gifts = gifts;
      renderList();
    }catch(e){
      console.error(e);
      alert('シートの読み込みに失敗しました。権限/CORS/URLをご確認ください。');
    }
  }
  async function loadSheet(sheetId, gid){
    const base  = 'https://docs.google.com/spreadsheets/d/' + sheetId + '/export?format=csv&gid=' + gid;
    const proxy = (elProxy.value || DEFAULT_PROXY).trim();
    const url = proxy.includes('url=') ? (proxy + encodeURIComponent(base)) : (proxy + base);
    const res = await fetch(url, {cache:'no-store'});
    if(!res.ok) throw new Error('シート取得に失敗（CORS/権限/URL）');
    const text = await res.text();
    const rows = csvToRows(text);
    if(!rows.length) return [];
    const header = rows[0].map(h=>h.trim());
    const map = Object.fromEntries(header.map((h,i)=>[h,i]));
    const list = rows.slice(1).map(r=>{
      const id = r[map['Gift ID']]||'';
      const name = r[map['Gift Name']]||'';
      const cost = Number(r[map['Gift Cost']]||0);
      let imageUrl = r[map['Gift Image URL']]||'';
      imageUrl = extractHyperlink(imageUrl);
      return {id,name,cost,imageUrl};
    }).filter(g=>g.id && g.name && g.imageUrl);
    return list;
  }

  // ======= Render: List & Slots =======
  function renderList(){
    elList.innerHTML='';
    S.gifts.forEach(g=>{
      const div = document.createElement('button');
      div.className='item';
      div.innerHTML = '<div class="name">'+escapeHtml(g.name)+'</div><div class="muted">🪙 '+g.cost+'</div>';
      div.onclick = ()=>{
        const slot = {
          gift:g,
          giftScale:100, giftOffX:0, giftOffY:0,
          overlayFile:null, overlayScale:100, overlayOffX:0, overlayOffY:0, overlayRot:0,
          text:'', textSize:Number(elFontSize.value||86), textColor:elFontColor.value||'#ffffff',
          textStroke:!!elFontStroke.checked, textAlign:elTextAlign.value, textVAlign:elTextVAlign.value,
          textOffX:Number(elTextOffX.value||0), textOffY:Number(elTextOffY.value||0)
        };
        S.slots.push(slot);
        renderSlots(); draw();
      };
      elList.appendChild(div);
    });
  }
  function renderSlots(){
    const g = gridSize();
    elSlots.style.gridTemplateColumns = 'repeat(' + Math.max(3,g.cols) + ',1fr)';
    elSlots.innerHTML='';
    const total = g.cols*g.rows;
    for(let i=0;i<total;i++){
      const slot = S.slots[i];
      const div = document.createElement('div');
      div.className='slot';
      div.innerHTML = '<div class="cap">スロット '+(i+1)+'</div>';
      if(slot){
        const head = document.createElement('div');
        head.className='compact';
        head.innerHTML = '<div class="name">'+escapeHtml(slot.gift.name)+' <span class="badge">/ 🪙'+slot.gift.cost+'</span></div><span class="rem" title="削除">削除</span>';
        head.querySelector('.rem').onclick = ()=>{ S.slots.splice(i,1); renderSlots(); draw(); };
        div.appendChild(head);

        const textRow = document.createElement('div');
        textRow.className='row';
        textRow.style.marginTop='6px';
        textRow.innerHTML = '<input type="text" placeholder="スロットのテキスト（任意）" value="'+escapeHtml(slot.text)+'">';
        textRow.querySelector('input').oninput = (e)=>{ slot.text = e.target.value; draw(); };
        div.appendChild(textRow);

        const grid1 = document.createElement('div');
        grid1.className='ctrl3';
        grid1.innerHTML = ''
          + '<div><label>アイコン倍率%</label><input type="number" value="'+slot.giftScale+'" min="10" max="300"></div>'
          + '<div><label>アイコンX</label><input type="number" value="'+slot.giftOffX+'" step="1"></div>'
          + '<div><label>アイコンY</label><input type="number" value="'+slot.giftOffY+'" step="1"></div>';
        const [inScale,inGX,inGY] = grid1.querySelectorAll('input');
        inScale.oninput = e=>{ slot.giftScale=Number(e.target.value||100); draw(); };
        inGX.oninput = e=>{ slot.giftOffX=Number(e.target.value||0); draw(); };
        inGY.oninput = e=>{ slot.giftOffY=Number(e.target.value||0); draw(); };
        div.appendChild(grid1);

        const grid2 = document.createElement('div');
        grid2.className='ctrl3';
        grid2.innerHTML = ''
          + '<div><label>追加画像</label><input type="file" accept="image/*"></div>'
          + '<div><label>追画像倍率%</label><input type="number" value="'+slot.overlayScale+'" min="10" max="300"></div>'
          + '<div><label>回転°</label><input type="number" value="'+slot.overlayRot+'" step="1"></div>'
          + '<div><label>追画像X</label><input type="number" value="'+slot.overlayOffX+'" step="1"></div>'
          + '<div><label>追画像Y</label><input type="number" value="'+slot.overlayOffY+'" step="1"></div>';
        const inputs2 = grid2.querySelectorAll('input');
        const up = inputs2[0];
        up.onchange = (e)=>{
          slot.overlayFile = e.target.files && e.target.files[0] ? e.target.files[0] : null;
          draw();
        };
        inputs2[1].oninput = e=>{ slot.overlayScale=Number(e.target.value||100); draw(); };
        inputs2[2].oninput = e=>{ slot.overlayRot=Number(e.target.value||0); draw(); };
        inputs2[3].oninput = e=>{ slot.overlayOffX=Number(e.target.value||0); draw(); };
        inputs2[4].oninput = e=>{ slot.overlayOffY=Number(e.target.value||0); draw(); };
        div.appendChild(grid2);

        const grid3 = document.createElement('div');
        grid3.className='ctrl3';
        grid3.innerHTML = ''
          + '<div><label>文字サイズ</label><input type="number" value="'+slot.textSize+'" min="10"></div>'
          + '<div><label>文字X</label><input type="number" value="'+slot.textOffX+'" step="1"></div>'
          + '<div><label>文字Y</label><input type="number" value="'+slot.textOffY+'" step="1"></div>';
        const [ts,tx,ty] = grid3.querySelectorAll('input');
        ts.oninput = e=>{ slot.textSize=Number(e.target.value||86); draw(); };
        tx.oninput = e=>{ slot.textOffX=Number(e.target.value||0); draw(); };
        ty.oninput = e=>{ slot.textOffY=Number(e.target.value||0); draw(); };
        div.appendChild(grid3);

      }else{
        const p = document.createElement('div');
        p.className='note'; p.textContent='（未配置）';
        div.appendChild(p);
      }
      elSlots.appendChild(div);
    }
  }

  // ======= Background pick =======
  async function onPickBg(e){
    const f = e.target.files && e.target.files[0];
    if(!f) return;
    try{
      const bmp = await blobToBitmap(f);
      S.bgBitmap = bmp;
      S.canvasW = bmp.width;
      S.canvasH = bmp.height;
      elPreview.width = S.canvasW;
      elPreview.height = S.canvasH;
      draw();
    }catch(err){
      alert('背景画像の読み込みに失敗しました');
    }
  }

  // ======= Drawing (preview) =======
  async function draw(){
    // clear
    ctx.fillStyle = '#0c1016';
    ctx.fillRect(0,0,elPreview.width, elPreview.height);
    // bg
    if(S.bgBitmap) ctx.drawImage(S.bgBitmap,0,0);
    const g = gridSize();
    const off = centerOffset(elPreview.width, elPreview.height, g.width, g.height);

    // guide
    if(elGuide.value==='ON'){
      ctx.save();
      ctx.strokeStyle = 'rgba(255,255,255,0.08)';
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      for(let r=0;r<g.rows;r++){
        for(let c=0;c<g.cols;c++){
          const x = off.x + g.gap + c*(g.tileW+g.gap);
          const y = off.y + g.gap + r*(g.tileH+g.gap);
          rr(ctx,x,y,g.tileW,g.tileH, Number(elRadius.value||0));
          ctx.fill(); ctx.stroke();
        }
      }
      ctx.restore();
    }

    if(!S._bmpCache) S._bmpCache = new Map();

    for(let i=0;i<g.rows*g.cols;i++){
      const slot = S.slots[i];
      const r = Math.floor(i/g.cols), c=i%g.cols;
      const x = off.x + g.gap + c*(g.tileW+g.gap);
      const y = off.y + g.gap + r*(g.tileH+g.gap);
      if(!slot) continue;

      // base gift image
      if(slot.gift && slot.gift.imageUrl){
        let bmp = S._bmpCache.get(slot.gift.imageUrl);
        if(!bmp){
          try{
            const blob = await fetchImageBlobWithFallback(slot.gift.imageUrl);
            bmp = await blobToBitmap(blob);
            S._bmpCache.set(slot.gift.imageUrl, bmp);
          }catch(e){ bmp = null; }
        }
        if(bmp){
          const scale = (slot.giftScale||100)/100;
          const pad = 14;
          const maxW = g.tileW - 2*pad, maxH = g.tileH - 2*pad;
          const ratio = Math.min(maxW/bmp.width, maxH/bmp.height) * scale;
          const iw = bmp.width*ratio, ih=bmp.height*ratio;
          const ix = x + (g.tileW-iw)/2 + (slot.giftOffX||0);
          const iy = y + (g.tileH-ih)/2 + (slot.giftOffY||0);
          ctx.drawImage(bmp, ix, iy, iw, ih);
        }
      }

      // overlay image
      if(slot.overlayFile){
        if(!slot._overlayBmp || slot._overlayBmpFile !== slot.overlayFile){
          try{
            slot._overlayBmp = await blobToBitmap(slot.overlayFile);
            slot._overlayBmpFile = slot.overlayFile;
          }catch(e){ slot._overlayBmp = null; }
        }
        const bmp2 = slot._overlayBmp;
        if(bmp2){
          const scale2 = (slot.overlayScale||100)/100;
          const pad = 14;
          const maxW2 = g.tileW - 2*pad, maxH2 = g.tileH - 2*pad;
          const ratio2 = Math.min(maxW2/bmp2.width, maxH2/bmp2.height) * scale2;
          const iw2 = bmp2.width*ratio2, ih2=bmp2.height*ratio2;
          const cx = x + g.tileW/2 + (slot.overlayOffX||0);
          const cy = y + g.tileH/2 + (slot.overlayOffY||0);
          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate((slot.overlayRot||0) * Math.PI/180);
          ctx.drawImage(bmp2, -iw2/2, -ih2/2, iw2, ih2);
          ctx.restore();
        }
      }

      // text on top
      drawSlotText(ctx, slot, x, y, g);
    }
  }

  // ======= Export =======
  async function exportPNG(){
    if(!S.bgBitmap){
      alert('背景画像を選んでください（PNG推奨）');
      return;
    }
    const g = gridSize();
    const off = centerOffset(elPreview.width, elPreview.height, g.width, g.height);
    const cvs = document.createElement('canvas');
    cvs.width = elPreview.width; cvs.height = elPreview.height;
    const c = cvs.getContext('2d');

    c.drawImage(S.bgBitmap,0,0);

    if(!S._bmpCache) S._bmpCache = new Map();

    for(let i=0;i<g.rows*g.cols;i++){
      const slot = S.slots[i];
      const r = Math.floor(i/g.cols), cidx=i%g.cols;
      const x = off.x + g.gap + cidx*(g.tileW+g.gap);
      const y = off.y + g.gap + r*(g.tileH+g.gap);
      if(!slot) continue;

      // base gift
      if(slot.gift && slot.gift.imageUrl){
        let bmp = S._bmpCache.get(slot.gift.imageUrl);
        if(!bmp){
          try{
            const blob = await fetchImageBlobWithFallback(slot.gift.imageUrl);
            bmp = await blobToBitmap(blob);
            S._bmpCache.set(slot.gift.imageUrl, bmp);
          }catch(e){ bmp = null; }
        }
        if(bmp){
          const scale = (slot.giftScale||100)/100;
          const pad = 14;
          const maxW = g.tileW - 2*pad, maxH = g.tileH - 2*pad;
          const ratio = Math.min(maxW/bmp.width, maxH/bmp.height) * scale;
          const iw = bmp.width*ratio, ih=bmp.height*ratio;
          const ix = x + (g.tileW-iw)/2 + (slot.giftOffX||0);
          const iy = y + (g.tileH-ih)/2 + (slot.giftOffY||0);
          c.drawImage(bmp, ix, iy, iw, ih);
        }
      }
      // overlay
      if(slot.overlayFile){
        if(!slot._overlayBmp || slot._overlayBmpFile !== slot.overlayFile){
          try{
            slot._overlayBmp = await blobToBitmap(slot.overlayFile);
            slot._overlayBmpFile = slot.overlayFile;
          }catch(e){ slot._overlayBmp = null; }
        }
        const bmp2 = slot._overlayBmp;
        if(bmp2){
          const scale2 = (slot.overlayScale||100)/100;
          const pad = 14;
          const maxW2 = g.tileW - 2*pad, maxH2 = g.tileH - 2*pad;
          const ratio2 = Math.min(maxW2/bmp2.width, maxH2/bmp2.height) * scale2;
          const iw2 = bmp2.width*ratio2, ih2=bmp2.height*ratio2;
          const cx = x + g.tileW/2 + (slot.overlayOffX||0);
          const cy = y + g.tileH/2 + (slot.overlayOffY||0);
          c.save();
          c.translate(cx, cy);
          c.rotate((slot.overlayRot||0) * Math.PI/180);
          c.drawImage(bmp2, -iw2/2, -ih2/2, iw2, ih2);
          c.restore();
        }
      }
      // text (optional include)
      if(elExportText.checked){
        drawSlotText(c, slot, x, y, g);
      }
    }

    try{
      const url = cvs.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url; a.download = 'gift_board.png'; a.click();
    }catch{
      alert('出力に失敗しました。別ドメイン画像が混じる場合はプロキシを使ってください。');
    }
  }

  function escapeHtml(s){return String(s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));}

  // ======= Init =======
  elSheetId.value = FIXED_SHEET_ID;
  elGid.value = FIXED_GID;
  if (!elProxy.value) elProxy.value = DEFAULT_PROXY;

  renderSlots();
  draw();

})();</script>
</body>
</html>
