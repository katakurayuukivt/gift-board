<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gift Board (TikTok 1080 default)</title>
  <style>
    :root{
      --bg:#0b1118; --card:#121826; --line:#233046; --muted:#9aa6b2; --accent:#60a5fa;
      --chip:#1b2234; --chipline:#2b3952;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,-apple-system,"Segoe UI","Noto Sans JP",Roboto,sans-serif}
    header{display:flex;gap:10px;align-items:center;padding:12px;border-bottom:1px solid var(--line);flex-wrap:wrap}
    header .grow{flex:1 1 auto}
    .btn{background:var(--accent);color:#0b0f17;border:none;padding:10px 14px;border-radius:12px;font-weight:700;cursor:pointer}
    .btn.sec{background:#1e293b;color:#e5e7eb;border:1px solid #2a3a55}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .input{background:#0c1220;border:1px solid #2a3a55;border-radius:10px;padding:8px 10px;color:#fff}
    .input[readonly]{opacity:.8}
    main{display:grid;grid-template-columns: 1fr 360px;gap:12px;padding:12px}
    .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:12px}
    .title{font-weight:800;margin-bottom:10px}
    .grid{display:grid;grid-template-columns: 1fr;gap:12px}
    /* 左：ライブプレビュー */
    #previewWrap{border:1px solid var(--line);border-radius:12px;background:#0d1422;padding:12px}
    canvas{display:block;max-width:100%}
    .range{width:260px}
    .chip{background:var(--chip);border:1px solid var(--chipline);border-radius:10px;padding:6px 8px;font-size:12px;color:var(--muted)}

    /* 右：ギフトとスロット編集 */
    .list{display:grid;grid-template-columns:1fr 1fr;gap:8px;max-height:40vh;overflow:auto}
    .giftbtn{background:#0f1626;border:1px solid #293852;border-radius:12px;padding:10px;cursor:pointer;text-align:left}
    .giftbtn .nm{font-weight:800}
    .slot{background:#0f1626;border:1px solid #2a3953;border-radius:14px;padding:10px}
    .slot .cap{font-size:12px;color:var(--muted);margin-bottom:6px}
    .slot img.thumb{width:44px;height:44px;object-fit:contain;background:#0c1220;border:1px solid #2a3953;border-radius:8px}
    .slot .rowline{display:flex;align-items:center;gap:10px;margin-bottom:6px}
    .slot .ctl{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .slot .ctl label{font-size:12px;color:var(--muted)}
    .slot input[type="text"], .slot input[type="number"], .slot select{width:100%;background:#0c1220;border:1px solid #2a3953;border-radius:8px;color:#fff;padding:6px 8px}
    .slot .sub{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:6px}
    .danger{color:#f87171;cursor:pointer;font-size:12px}
    .small{font-size:12px;color:var(--muted)}
    @media (max-width: 980px){ main{grid-template-columns:1fr} }
  </style>
</head>
<body>
  <header>
    <div class="row grow">
      <span class="chip">TikTok想定：出力幅デフォルト 1080px、3行×6列</span>
    </div>
    <button class="btn sec" id="bgBtn">背景画像を選ぶ</button>
    <button class="btn" id="saveBtn">PNGとして保存</button>
  </header>

  <main>
    <section class="panel">
      <div class="title">ライブプレビュー</div>
      <div class="row" style="gap:14px;flex-wrap:wrap;margin-bottom:10px">
        <label class="chip">出力幅(px) <input id="outWidth" class="input" type="number" value="1080" style="width:120px"></label>
        <label class="chip">列(COLS) <input id="cols" class="input" type="number" value="6" style="width:80px"></label>
        <label class="chip">行(ROWS) <input id="rows" class="input" type="number" value="3" style="width:80px"></label>
        <label class="chip">枠幅 TILE_W <input id="tileW" class="input" type="number" value="320" style="width:100px"></label>
        <label class="chip">枠高 TILE_H <input id="tileH" class="input" type="number" value="180" style="width:100px"></label>
        <label class="chip">枠間 GAP <input id="gap" class="input" type="number" value="20" style="width:90px"></label>
        <label class="chip">丸角(px) <input id="radius" class="input" type="number" value="18" style="width:90px"></label>
        <label class="chip">ズーム <input id="zoom" type="range" min="50" max="200" value="100" class="range"> <span id="zoomLbl">100%</span></label>
      </div>
      <div id="previewWrap">
        <canvas id="preview" width="1080" height="540"></canvas>
      </div>
      <div class="small" style="margin-top:6px">※ 右の「スロット編集」で各枠のテキスト・画像差分・ギフト画像の位置/倍率を調整できます。</div>
    </section>

    <section class="panel">
      <div class="title">ギフト一覧 / スロット編集</div>
      <div class="row" style="margin-bottom:10px;gap:8px">
        <label class="chip">Sheet ID <input id="sheetId" class="input" value="15QtBjbdETvUNL64JF46MvTvkfXaZI_jAtTphKQH6Y5U" style="width:340px"></label>
        <label class="chip">gid <input id="gid" class="input" value="1487601753" style="width:120px"></label>
      </div>
      <div class="row" style="margin-bottom:10px;gap:8px">
        <label class="chip">CORSプロキシURL（任意） <input id="proxy" class="input" placeholder="https://api.allorigins.win/raw?url=" style="width:340px"></label>
        <button class="btn sec" id="loadBtn">読み込む</button>
        <input type="file" id="bgFile" accept="image/*" hidden>
        <input type="file" id="fontFile" accept=".ttf,.otf,.woff,.woff2" hidden>
        <button class="btn sec" id="fontBtn">フォントをアップロード</button>
      </div>

      <div class="title" style="margin-top:4px;font-size:14px">ギフト一覧（クリックで追加）</div>
      <div id="giftList" class="list" style="margin-bottom:12px"></div>

      <div class="title" style="margin-top:4px;font-size:14px">配置中（最大 任意の行×列）</div>
      <div id="slotWrap" class="grid"></div>
    </section>
  </main>

<script>
(function(){
  // ====== 基本設定 ======
  const el = (id)=>document.getElementById(id);
  const preview = el('preview');
  const pctx = preview.getContext('2d');

  // UI要素
  const ui = {
    cols: el('cols'), rows: el('rows'),
    tileW: el('tileW'), tileH: el('tileH'),
    gap: el('gap'), radius: el('radius'),
    outWidth: el('outWidth'), zoom: el('zoom'), zoomLbl: el('zoomLbl'),
    previewWrap: el('previewWrap'),
    sheetId: el('sheetId'), gid: el('gid'), proxy: el('proxy'),
    giftList: el('giftList'), slotWrap: el('slotWrap'),
    bgBtn: el('bgBtn'), bgFile: el('bgFile'),
    fontBtn: el('fontBtn'), fontFile: el('fontFile'),
    loadBtn: el('loadBtn'), saveBtn: el('saveBtn'),
  };

  // データ
  let allGifts = [];        // {id,name,cost,imageUrl}
  let slots = [];           // per-slot object
  let uploadedFonts = [];   // {family, source}
  let bgImage = null;       // Image or null

  function gridW(){ return Number(ui.cols.value)*Number(ui.tileW.value) + (Number(ui.cols.value)+1)*Number(ui.gap.value); }
  function gridH(){ return Number(ui.rows.value)*Number(ui.tileH.value) + (Number(ui.rows.value)+1)*Number(ui.gap.value); }

  // スロット初期オブジェクト
  function makeSlot(){
    return {
      gift:null,
      giftScale:100, giftOffX:0, giftOffY:0,
      overlay:null, overlayScale:100, overlayOffX:0, overlayOffY:0,
      text:"", textSize:64, textColor:"#ffffff", textStroke:true, textFont:"system-ui",
      textAlignH:"center", textAlignV:"middle", textOffX:0, textOffY:0
    };
  }

  function ensureSlots(){
    const total = Number(ui.cols.value) * Number(ui.rows.value);
    while(slots.length < total) slots.push(makeSlot());
    if(slots.length > total) slots.length = total;
  }

  // ====== CSV 読み込み ======
  function csvToRows(s){
    const rows=[]; let i=0, c="", row=[], inQ=false;
    while(i<s.length){
      const ch=s[i];
      if(inQ){
        if(ch=='"'){ if(s[i+1]=='"'){ c+='"'; i+=2; } else { inQ=false; i++; } }
        else { c+=ch; i++; }
      }else{
        if(ch=='"'){ inQ=true; i++; }
        else if(ch==','){ row.push(c); c=""; i++; }
        else if(ch=='\n'){ row.push(c); rows.push(row); c=""; row=[]; i++; }
        else if(ch=='\r'){ i++; }
        else { c+=ch; i++; }
      }
    }
    row.push(c); rows.push(row);
    return rows;
  }

  async function fetchTextWithProxy(url){
    const way = [];
    const user = (ui.proxy.value||"").trim();
    if(user) way.push(user + encodeURIComponent(url));
    way.push("https://cors.isomorphic-git.org/" + url);
    way.push(url);
    for(const u of way){
      try{
        const r = await fetch(u, {cache:"no-store"});
        if(!r.ok) continue;
        return await r.text();
      }catch(e){}
    }
    throw new Error("fetch failed");
  }

  async function loadSheet(){
    const sid = ui.sheetId.value.trim();
    const gid = ui.gid.value.trim();
    if(!sid || !gid) { alert("Sheet ID と gid を入力してください"); return; }
    const csvUrl = `https://docs.google.com/spreadsheets/d/${sid}/export?format=csv&gid=${gid}`;
    const text = await fetchTextWithProxy(csvUrl);
    const rows = csvToRows(text);
    const header = rows[0].map(h=>h.trim());
    const m = Object.fromEntries(header.map((h,i)=>[h,i]));
    allGifts = rows.slice(1).map(r=>{
      return {
        id: r[m["Gift ID"]]||"",
        name: r[m["Gift Name"]]||"",
        cost: Number(r[m["Gift Cost"]]||0),
        imageUrl: extractUrl((r[m["Gift Image URL"]]||"").trim())
      };
    }).filter(g=>g.id && g.name && g.imageUrl);
    renderGiftList();
  }

  // ハイパーリンク式 "HYPERLINK(url, 表示名)" からURL抽出にも対応
  function extractUrl(val){
    if(!val) return "";
    // 既に http ならそのまま
    if(/^https?:/i.test(val)) return val;
    // HYPERLINK("...", "...")
    const m = val.match(/HYPERLINK\(["']([^"']+)["']/i);
    if(m) return m[1];
    return val;
  }

  // ====== 画像取得（Blob→ObjectURL） ======
  async function fetchImageBlobWithFallback(rawUrl){
    const ways=[]; const user=(ui.proxy.value||"").trim();
    if(user) ways.push(user + encodeURIComponent(rawUrl));
    try{
      const u = new URL(rawUrl);
      ways.push(`https://images.weserv.nl/?url=${u.host}${u.pathname}${u.search}`);
    }catch(e){}
    ways.push("https://cors.isomorphic-git.org/" + rawUrl);
    ways.push(rawUrl);
    for(const u of ways){
      try{
        const res = await fetch(u, {cache:"no-store"});
        if(!res.ok) continue;
        const b = await res.blob();
        if((b.type||"").startsWith("image/")) return b;
      }catch(e){}
    }
    throw new Error("image fetch failed");
  }

  async function blobToImage(blob){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      const url = URL.createObjectURL(blob);
      img.onload = ()=>{ URL.revokeObjectURL(url); resolve(img); };
      img.onerror = reject;
      img.src = url;
    });
  }

  // ====== UI レンダリング ======
  function renderGiftList(){
    ui.giftList.innerHTML = "";
    for(const g of allGifts){
      const b = document.createElement("button");
      b.className = "giftbtn";
      b.innerHTML = `<div class="nm">${escapeHtml(g.name)}</div><div class="small">🪙 ${g.cost}</div>`;
      b.onclick = () => {
        ensureSlots();
        // 空きスロットへ
        const idx = slots.findIndex(s=>!s.gift);
        if(idx>=0){ slots[idx].gift = g; } else { slots.push(Object.assign(makeSlot(), {gift:g})); }
        renderSlots(); draw();
      };
      ui.giftList.appendChild(b);
    }
  }

  function renderSlots(){
    ensureSlots();
    ui.slotWrap.innerHTML = "";
    slots.forEach((s,idx)=>{
      const wrap = document.createElement("div");
      wrap.className = "slot";
      const cap = document.createElement("div");
      cap.className = "cap";
      cap.textContent = `スロット ${idx+1}`;
      wrap.appendChild(cap);

      const line = document.createElement("div");
      line.className = "rowline";
      if(s.gift){
        const im = document.createElement("img");
        im.className = "thumb";
        im.alt = s.gift.name;
        // set thumb async
        fetchImageBlobWithFallback(s.gift.imageUrl).then(b=>blobToImage(b)).then(img=>{
          im.src = img.src;
        }).catch(()=>{});
        const nm = document.createElement("div");
        nm.textContent = `${s.gift.name} / 🪙${s.gift.cost}`;
        nm.style.fontWeight="800";
        const del = document.createElement("span");
        del.className="danger"; del.textContent="削除";
        del.onclick=()=>{ slots[idx]=makeSlot(); renderSlots(); draw(); };
        line.appendChild(im); line.appendChild(nm); line.appendChild(del);
      }else{
        const mt = document.createElement("div");
        mt.className="small"; mt.textContent="（未配置）";
        line.appendChild(mt);
      }
      wrap.appendChild(line);

      // ギフト画像調整
      const ctl1 = document.createElement("div");
      ctl1.className="ctl";
      ctl1.innerHTML = `
        <div><label>ギフト倍率(%)<input type="number" value="${s.giftScale}" min="10" max="400" step="1"></label></div>
        <div><label>ギフト余白(px)<input type="number" value="${s.giftOffX}" step="1"></label></div>
        <div><label>位置X(px)<input type="number" value="${s.giftOffX}" step="1"></label></div>
        <div><label>位置Y(px)<input type="number" value="${s.giftOffY}" step="1"></label></div>
      `;
      const nums = ctl1.querySelectorAll("input");
      nums[0].oninput = e=>{ s.giftScale = Number(e.target.value||100); draw(); };
      // 修正: 2番目は余白をギフト余白に、3/4 は位置X/Y
      nums[1].oninput = e=>{ s.giftOffX = Number(e.target.value||0); draw(); };
      nums[2].oninput = e=>{ s.giftOffX = Number(e.target.value||0); draw(); };
      nums[3].oninput = e=>{ s.giftOffY = Number(e.target.value||0); draw(); };
      wrap.appendChild(ctl1);

      // 追加画像
      const sub = document.createElement("div");
      sub.className = "sub";
      sub.innerHTML = `
        <div><label>追加画像<input type="file" accept="image/*"></label></div>
        <div><label>倍率(%)<input type="number" value="${s.overlayScale}" min="10" max="400"></label></div>
        <div><label>位置X(px)<input type="number" value="${s.overlayOffX}"></label></div>
        <div><label>位置Y(px)<input type="number" value="${s.overlayOffY}"></label></div>
      `;
      const overlayFile = sub.querySelector('input[type="file"]');
      overlayFile.onchange = async (e)=>{
        const f = e.target.files[0]; if(!f) return;
        const b = await f.arrayBuffer();
        const blob = new Blob([new Uint8Array(b)], {type: f.type||"image/png"});
        const img = await blobToImage(blob);
        s.overlay = img;
        draw();
      };
      const ovNum = sub.querySelectorAll('input[type="number"]');
      ovNum[0].oninput = e=>{ s.overlayScale = Number(e.target.value||100); draw(); };
      ovNum[1].oninput = e=>{ s.overlayOffX = Number(e.target.value||0); draw(); };
      ovNum[2].oninput = e=>{ s.overlayOffY = Number(e.target.value||0); draw(); };
      wrap.appendChild(sub);

      // テキスト
      const txt = document.createElement("div");
      txt.className = "ctl";
      txt.innerHTML = `
        <div style="grid-column: span 2;"><label>テキスト<input type="text" value="${escapeHtmlAttr(s.text)}" maxlength="40"></label></div>
        <div><label>文字サイズ(px)<input type="number" value="${s.textSize}" min="8" max="200"></label></div>
        <div><label>色<input type="color" value="${s.textColor}"></label></div>
        <div><label>縁取り<select>
            <option value="true"${s.textStroke?" selected":""}>ON</option>
            <option value="false"${!s.textStroke?" selected":""}>OFF</option>
        </select></label></div>
        <div><label>フォント
            <select class="fontSel"></select>
        </label></div>
        <div><label>水平位置<select>
            <option value="left"${s.textAlignH==="left"?" selected":""}>左</option>
            <option value="center"${s.textAlignH==="center"?" selected":""}>中央</option>
            <option value="right"${s.textAlignH==="right"?" selected":""}>右</option>
        </select></label></div>
        <div><label>垂直位置<select>
            <option value="top"${s.textAlignV==="top"?" selected":""}>上</option>
            <option value="middle"${s.textAlignV==="middle"?" selected":""}>中央</option>
            <option value="bottom"${s.textAlignV==="bottom"?" selected":""}>下</option>
        </select></label></div>
        <div><label>オフセットX<input type="number" value="${s.textOffX}" step="1"></label></div>
        <div><label>オフセットY<input type="number" value="${s.textOffY}" step="1"></label></div>
      `;
      // フォントセレクタを現在のリストで埋める
      const fontSel = txt.querySelector(".fontSel");
      fillFontOptions(fontSel, s.textFont);
      fontSel.onchange = (e)=>{ s.textFont = e.target.value; draw(); };

      const tInputs = txt.querySelectorAll('input[type="text"],input[type="number"],input[type="color"]');
      tInputs[0].oninput = e=>{ s.text = e.target.value; draw(); };
      tInputs[1].oninput = e=>{ s.textSize = Number(e.target.value||64); draw(); };
      tInputs[2].oninput = e=>{ s.textColor = e.target.value; draw(); };
      const tSelects = txt.querySelectorAll('select');
      tSelects[0].onchange = e=>{ s.textStroke = (e.target.value==="true"); draw(); };
      tSelects[1].onchange = e=>{ /* font handled above */ };
      tSelects[2].onchange = e=>{ s.textAlignH = e.target.value; draw(); };
      tSelects[3].onchange = e=>{ s.textAlignV = e.target.value; draw(); };
      const offs = txt.querySelectorAll('input[type="number"]');
      offs[2].oninput = e=>{ s.textOffX = Number(e.target.value||0); draw(); };
      offs[3].oninput = e=>{ s.textOffY = Number(e.target.value||0); draw(); };
      wrap.appendChild(txt);

      ui.slotWrap.appendChild(wrap);
    });
  }

  function fillFontOptions(sel, current){
    const base = ["system-ui","Noto Sans JP","BIZ UDPGothic","BIZ UDGothic","Yu Gothic UI","Meiryo"];
    sel.innerHTML = "";
    for(const f of base){
      const opt = document.createElement("option");
      opt.value = f; opt.textContent = f;
      if(current===f) opt.selected = true;
      sel.appendChild(opt);
    }
    for(const f of uploadedFonts){
      const opt = document.createElement("option");
      opt.value = f.family; opt.textContent = f.family + " (uploaded)";
      if(current===f.family) opt.selected = true;
      sel.appendChild(opt);
    }
  }

  // ====== 描画 ======
  function draw(){
    const gw = gridW(), gh = gridH();
    const scale = Number(ui.zoom.value)/100;
    const pw = Math.round(gw*scale), ph = Math.round(gh*scale);
    preview.width = pw; preview.height = ph;
    pctx.clearRect(0,0,pw,ph);

    // 背景 (プレビューでは薄くグリッドだけ、背景画像は出力時のみ描画)
    // ガイド枠 & スロット内容
    const cols = Number(ui.cols.value), rows=Number(ui.rows.value);
    const W = Number(ui.tileW.value), H=Number(ui.tileH.value), G=Number(ui.gap.value), R=Number(ui.radius.value);

    const ox = 0, oy = 0; // プレビューは左上原点
    pctx.lineWidth = 2;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const x = G + c*(W+G);
        const y = G + r*(H+G);
        roundRect(pctx, (ox+x)*scale, (oy+y)*scale, W*scale, H*scale, R*scale);
        pctx.strokeStyle = "rgba(148,163,184,.35)";
        pctx.stroke();
        const s = slots[r*cols+c];
        if(!s || !s.gift) continue;
        // ギフト画像
        drawGiftInto(pctx, s, (ox+x)*scale, (oy+y)*scale, W*scale, H*scale, scale);
        // 追加画像
        if(s.overlay) drawOverlayInto(pctx, s, (ox+x)*scale, (oy+y)*scale, W*scale, H*scale, scale);
        // テキスト
        if(s.text) drawTextInto(pctx, s, (ox+x)*scale, (oy+y)*scale, W*scale, H*scale, scale);
      }
    }
  }

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // 画像描画ヘルパ
  const giftImgCache = new Map(); // url -> Image
  async function getGiftImage(url){
    if(giftImgCache.has(url)) return giftImgCache.get(url);
    try{
      const b = await fetchImageBlobWithFallback(url);
      const img = await blobToImage(b);
      giftImgCache.set(url, img);
      return img;
    }catch(e){
      return null;
    }
  }

  function drawGiftInto(ctx, s, x,y,w,h, scale){
    const img = giftImgCache.get(s.gift.imageUrl);
    if(!img) return;
    // 内側に収まるように拡大（倍率%）し、オフセットを加える
    const maxW = w - 2*scale*8, maxH = h - 2*scale*8;
    const r = Math.min(maxW/img.naturalWidth, maxH/img.naturalHeight) * (s.giftScale/100);
    const iw = img.naturalWidth * r, ih = img.naturalHeight * r;
    const cx = x + (w - iw)/2 + s.giftOffX*scale;
    const cy = y + (h - ih)/2 + s.giftOffY*scale;
    ctx.drawImage(img, cx, cy, iw, ih);
  }

  function drawOverlayInto(ctx, s, x,y,w,h, scale){
    const img = s.overlay;
    if(!img) return;
    const r = (s.overlayScale/100);
    const iw = img.naturalWidth * r * scale;
    const ih = img.naturalHeight * r * scale;
    const cx = x + w/2 - iw/2 + s.overlayOffX*scale;
    const cy = y + h/2 - ih/2 + s.overlayOffY*scale;
    ctx.drawImage(img, cx, cy, iw, ih);
  }

  async function ensureFontLoaded(family){
    try{
      await document.fonts.load(`16px "${family}"`);
    }catch(e){}
  }

  function drawTextInto(ctx, s, x,y,w,h, scale){
    ctx.save();
    ctx.font = `700 ${Math.round(s.textSize*scale)}px "${s.textFont}"`;
    ctx.textBaseline = "middle";
    let tx = x + w/2, ty = y + h/2;
    if(s.textAlignH==="left")   tx = x + 8*scale;
    if(s.textAlignH==="right")  tx = x + w - 8*scale;
    if(s.textAlignV==="top")    ty = y + 18*scale;
    if(s.textAlignV==="bottom") ty = y + h - 18*scale;
    tx += s.textOffX*scale; ty += s.textOffY*scale;
    ctx.textAlign = s.textAlignH;
    if(s.textStroke){
      ctx.lineWidth = Math.max(2, Math.round(s.textSize*0.08*scale));
      ctx.strokeStyle = "rgba(0,0,0,.85)";
      ctx.strokeText(s.text, tx, ty);
    }
    ctx.fillStyle = s.textColor;
    ctx.fillText(s.text, tx, ty);
    ctx.restore();
  }

  // ====== 背景・出力 ======
  ui.bgBtn.onclick = ()=> ui.bgFile.click();
  ui.bgFile.onchange = async (e)=>{
    const f = e.target.files[0]; if(!f) return;
    const b = await f.arrayBuffer();
    const blob = new Blob([new Uint8Array(b)], {type: f.type||"image/png"});
    try{ bgImage = await blobToImage(blob); }catch(e){ bgImage=null; }
    draw();
  };

  // フォントアップロード（FontFace API）
  ui.fontBtn.onclick = ()=> ui.fontFile.click();
  ui.fontFile.onchange = async (e)=>{
    const f = e.target.files[0]; if(!f) return;
    const arr = await f.arrayBuffer();
    const family = f.name.replace(/\.(ttf|otf|woff2?|TTF|OTF|WOFF2?)$/,"");
    try{
      const ff = new FontFace(family, arr);
      await ff.load();
      document.fonts.add(ff);
      uploadedFonts.push({family});
      // 既存セレクト更新
      document.querySelectorAll(".fontSel").forEach(sel=>{
        const cur = sel.value;
        fillFontOptions(sel, cur);
      });
      draw();
      alert(`フォント "${family}" を読み込みました。各スロットのフォントで選択できます。`);
    }catch(err){
      alert("フォントの読み込みに失敗しました");
    }
  };

  ui.saveBtn.onclick = async ()=>{
    // 出力サイズ
    let outW = Number(ui.outWidth.value||1080);
    let outH;
    const gw = gridW(), gh = gridH();
    if(bgImage){
      outW = bgImage.naturalWidth;
      outH = bgImage.naturalHeight;
    }else{
      const ratio = gw>0 ? (Number(ui.outWidth.value||1080)/gw) : 1;
      outW = Number(ui.outWidth.value||1080);
      outH = Math.round(gh * ratio);
    }
    const c = document.createElement("canvas");
    c.width = outW; c.height = outH;
    const ctx = c.getContext("2d");
    // 背景
    if(bgImage){
      ctx.drawImage(bgImage, 0, 0, outW, outH);
    }else{
      ctx.fillStyle = "#0f1723";
      ctx.fillRect(0,0,outW,outH);
    }
    const cols = Number(ui.cols.value), rows=Number(ui.rows.value);
    const W = Number(ui.tileW.value), H=Number(ui.tileH.value), G=Number(ui.gap.value), R=Number(ui.radius.value);
    const gw0 = gridW(), gh0 = gridH();
    // 中央配置
    const scale = outW / gw0;
    const ox = (outW - gw0*scale)/2;
    const oy = (outH - gh0*scale)/2;

    // 描画ループ
    for(let r=0;r<rows;r++){
      for(let cidx=0;cidx<cols;cidx++){
        const x0 = G + cidx*(W+G);
        const y0 = G + r*(H+G);
        const x = ox + x0*scale;
        const y = oy + y0*scale;
        const w = W*scale, h = H*scale;

        const s = slots[r*cols+cidx];
        if(!s || !s.gift) continue;
        // 画像・追加・テキスト
        // 先にギフト画像読み込みが済んでいなければ待機
        const img = await getGiftImage(s.gift.imageUrl);
        if(img){
          const maxW = w - 2*scale*8, maxH = h - 2*scale*8;
          const rr = Math.min(maxW/img.naturalWidth, maxH/img.naturalHeight) * (s.giftScale/100);
          const iw = img.naturalWidth * rr, ih = img.naturalHeight * rr;
          const cx = x + (w - iw)/2 + s.giftOffX*scale;
          const cy = y + (h - ih)/2 + s.giftOffY*scale;
          ctx.drawImage(img, cx, cy, iw, ih);
        }
        if(s.overlay){
          const rr = (s.overlayScale/100);
          const iw = s.overlay.naturalWidth * rr * scale;
          const ih = s.overlay.naturalHeight * rr * scale;
          const cx = x + w/2 - iw/2 + s.overlayOffX*scale;
          const cy = y + h/2 - ih/2 + s.overlayOffY*scale;
          ctx.drawImage(s.overlay, cx, cy, iw, ih);
        }
        if(s.text){
          await ensureFontLoaded(s.textFont);
          ctx.save();
          ctx.font = `700 ${Math.round(s.textSize*scale)}px "${s.textFont}"`;
          ctx.textBaseline = "middle";
          let tx = x + w/2, ty = y + h/2;
          if(s.textAlignH==="left")   tx = x + 8*scale;
          if(s.textAlignH==="right")  tx = x + w - 8*scale;
          if(s.textAlignV==="top")    ty = y + 18*scale;
          if(s.textAlignV==="bottom") ty = y + h - 18*scale;
          tx += s.textOffX*scale; ty += s.textOffY*scale;
          ctx.textAlign = s.textAlignH;
          if(s.textStroke){
            ctx.lineWidth = Math.max(2, Math.round(s.textSize*0.08*scale));
            ctx.strokeStyle = "rgba(0,0,0,.85)";
            ctx.strokeText(s.text, tx, ty);
          }
          ctx.fillStyle = s.textColor;
          ctx.fillText(s.text, tx, ty);
          ctx.restore();
        }
      }
    }

    try{
      const url = c.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = url; a.download = "gift_board.png"; a.click();
    }catch(e){
      alert("PNG出力に失敗しました");
    }
  };

  // ====== イベント ======
  ["cols","rows","tileW","tileH","gap","radius","zoom"].forEach(k=>{
    ui[k].addEventListener("input", ()=>{ ui.zoomLbl.textContent = ui.zoom.value+"%"; ensureSlots(); renderSlots(); draw(); });
  });
  ui.loadBtn.onclick = async ()=>{
    try{
      await loadSheet();
      ensureSlots(); renderSlots(); draw();
    }catch(e){
      console.error(e);
      alert("シートの読み込みに失敗しました。権限とURL、CORSプロキシを確認してください。");
    }
  };

  // 初期化
  ensureSlots(); renderSlots(); draw();

  // ====== util ======
  function escapeHtml(s){ return s.replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;" }[m])); }
  function escapeHtmlAttr(s){ return escapeHtml(String(s)).replace(/"/g,"&quot;"); }
})();
</script>
</body>
</html>
