<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Gift Board Builder</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&family=Nunito:wght@400;800&family=Montserrat:wght@700&family=IBM+Plex+Sans+JP:wght@400;700&family=Rampart+One&display=swap" rel="stylesheet">
<style>
:root{--bg:#0e1218;--card:#151a22;--muted:#93a3b8;--accent:#60a5fa;--line:#283140}
*{box-sizing:border-box}
body{margin:0;background:var(--bg);color:#e5e7eb;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans JP",sans-serif}
header{display:flex;gap:10px;align-items:end;flex-wrap:wrap;padding:14px;border-bottom:1px solid #1e2531}
header .g{display:flex;flex-direction:column;gap:6px}
header label{font-size:12px;color:var(--muted)}
input[type=text],input[type=number],select{background:#0b0f15;border:1px solid #2a3140;color:#fff;border-radius:8px;padding:8px 10px}
button{background:var(--accent);border:none;color:#08101f;font-weight:800;border-radius:10px;padding:10px 14px;cursor:pointer}
main{display:grid;grid-template-columns:1fr 380px;gap:14px;padding:14px}
.panel{background:var(--card);border:1px solid #263044;border-radius:14px;padding:12px}
h3{margin:0 0 10px;font-size:16px}
.row{display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:8px;margin-bottom:10px}
.row > .col{display:flex;flex-direction:column;gap:6px}
small{color:var(--muted)}
#list{display:grid;grid-template-columns:1fr;gap:8px;max-height:70vh;overflow:auto}
.item{display:flex;justify-content:space-between;align-items:center;background:#0f1623;border:1px solid #2f3a4f;padding:10px 12px;border-radius:10px;cursor:pointer}
.item b{font-weight:800}
#slots{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
.slot{background:#111722;border:1px solid #2a3140;border-radius:12px;padding:10px;display:flex;flex-direction:column;gap:8px;min-height:120px}
.slot .cap{font-size:12px;color:var(--muted)}
.slot .row1{display:flex;gap:10px;align-items:center}
.slot img{width:56px;height:56px;object-fit:contain;background:#0b0f15;border:1px solid #2a3140;border-radius:10px}
.slot .name{font-weight:800}
.slot input[type=text]{width:100%}
.hr{height:1px;background:#232a38;margin:10px 0}
.controls{display:grid;grid-template-columns:repeat(6,minmax(0,1fr));gap:10px}
.controls .span2{grid-column:span 2}
.controls .span3{grid-column:span 3}
.controls .span6{grid-column:span 6}
#previewWrap{background:#0b0f15;border:1px solid #2a3140;border-radius:12px;padding:8px;margin-top:10px}
#preview{width:100%;height:560px;background:#0b0f15;border-radius:8px}
.note{color:var(--muted);font-size:12px}
.badge{display:inline-block;border:1px solid #2a3140;border-radius:8px;padding:5px 8px;background:#0e141f}
</style>
</head>
<body>
<header>
  <div class="g">
    <label>Sheet ID（固定）</label>
    <input id="sheet" type="text" value="15QtBjbdETvUNL64JF46MvTvkfXaZI_jAtTphKQH6Y5U" readonly>
  </div>
  <div class="g">
    <label>gid（固定）</label>
    <input id="gid" type="text" value="1487601753" readonly>
  </div>
  <div class="g" style="min-width:360px">
    <label>CORSプロキシURL（任意）</label>
    <input id="proxy" type="text" placeholder="例）https://api.allorigins.win/raw?url=" value="https://api.allorigins.win/raw?url=">
  </div>
  <div class="g">
    <button id="load">読み込む</button>
  </div>
  <div class="g">
    <button id="bgBtn">背景画像を選ぶ</button>
    <input id="bgFile" type="file" accept="image/*" style="display:none">
  </div>
  <div class="g" style="margin-left:auto">
    <button id="savePng">PNGとして保存</button>
    <label class="note"><input type="checkbox" id="withText"> テキストも出力</label>
  </div>
</header>

<main>
  <section class="panel">
    <h3>ライブプレビュー</h3>
    <div class="controls">
      <div class="col">
        <label>列（COLS）</label><input id="cols" type="number" min="1" max="12" value="6">
      </div>
      <div class="col">
        <label>行（ROWS）</label><input id="rows" type="number" min="1" max="12" value="3">
      </div>
      <div class="col">
        <label>枠幅 TILE_W</label><input id="tileW" type="number" value="320">
      </div>
      <div class="col">
        <label>枠高 TILE_H</label><input id="tileH" type="number" value="180">
      </div>
      <div class="col">
        <label>枠間 GAP</label><input id="gap" type="number" value="20">
      </div>
      <div class="col">
        <label>丸角 px</label><input id="radius" type="number" value="18">
      </div>

      <div class="col">
        <label>左上オフセットX</label><input id="offX" type="number" value="0">
      </div>
      <div class="col">
        <label>左上オフセットY</label><input id="offY" type="number" value="0">
      </div>
      <div class="col">
        <label>アイコン倍率（％・タイル基準）</label><input id="iconScale" type="range" min="50" max="200" value="100">
        <small id="iconScaleLabel">現在: 100%</small>
      </div>
      <div class="col">
        <label>アイコン余白 px</label><input id="iconPad" type="number" value="14">
      </div>
      <div class="col">
        <label>はみ出しOK（タイル外へ）</label>
        <select id="overflow"><option value="0">OFF</option><option value="1">ON</option></select>
      </div>
      <div class="col">
        <label>ガイド枠描画</label>
        <select id="guide"><option value="1">ON</option><option value="0">OFF</option></select>
      </div>

      <div class="span2 col">
        <label>テキスト（プレビュー用／スロットごと）</label>
        <small>各スロットの入力欄に記入してください</small>
      </div>
      <div class="col">
        <label>文字サイズ px</label><input id="textSize" type="number" value="86">
      </div>
      <div class="col">
        <label>文字色</label><input id="textColor" type="color" value="#ffffff">
      </div>
      <div class="col">
        <label>縁</label><input id="textStroke" type="color" value="#000000">
        <label class="note"><input type="checkbox" id="textStrokeOn" checked> 有効</label>
      </div>
      <div class="col">
        <label>フォント</label>
        <select id="fontFamily">
          <option value="Noto Sans JP, sans-serif">Noto Sans JP</option>
          <option value="IBM Plex Sans JP, sans-serif">IBM Plex Sans JP</option>
          <option value="Nunito, sans-serif">Nunito</option>
          <option value="Montserrat, sans-serif">Montserrat</option>
          <option value="Rampart One, cursive">Rampart One</option>
          <option value="system-ui, sans-serif">system-ui</option>
        </select>
      </div>
      <div class="col">
        <label>揃え（横）</label>
        <select id="textAlignX">
          <option value="left">左</option>
          <option value="center" selected>中央</option>
          <option value="right">右</option>
        </select>
      </div>
      <div class="col">
        <label>揃え（縦）</label>
        <select id="textAlignY">
          <option value="top">上</option>
          <option value="middle" selected>中央</option>
          <option value="bottom">下</option>
        </select>
      </div>
      <div class="col">
        <label>文字オフセットX</label><input id="textOffX" type="number" value="0">
      </div>
      <div class="col">
        <label>文字オフセットY</label><input id="textOffY" type="number" value="0">
      </div>
    </div>

    <div id="previewWrap">
      <canvas id="preview"></canvas>
    </div>
    <div class="note">※ 生成PNGはデフォルトでテキストを描画しません（オプションで含めることは可能）。</div>
  </section>

  <aside class="panel">
    <h3>ギフト一覧（クリックで追加）</h3>
    <div id="list"></div>
    <div class="hr"></div>
    <h3>配置中（最大 任意の行×列）</h3>
    <div id="slots"></div>
  </aside>
</main>

<script>
(() => {
  "use strict";
  // ====== constants / state ======
  const SHEET_ID = document.getElementById("sheet").value.trim();
  const GID = document.getElementById("gid").value.trim();
  let all = [];           // full gift list
  let picked = [];        // current placements (array length <= rows*cols)
  const imgCache = new Map();
  let bgImage = null;     // ImageBitmap for background
  let bgSize = {w:1280,h:720};

  // ====== DOM refs ======
  const d = (id)=>document.getElementById(id);
  const list = d("list");
  const slots = d("slots");
  const proxyInput = d("proxy");
  const canvas = d("preview");
  const ctx = canvas.getContext("2d");

  // controls
  const colsEl=d("cols"), rowsEl=d("rows"), tileWEl=d("tileW"), tileHEl=d("tileH"), gapEl=d("gap"), radEl=d("radius");
  const offXEl=d("offX"), offYEl=d("offY");
  const iconScaleEl=d("iconScale"), iconScaleLabel=d("iconScaleLabel");
  const iconPadEl=d("iconPad"), overflowEl=d("overflow"), guideEl=d("guide");
  const textSizeEl=d("textSize"), textColorEl=d("textColor"), textStrokeEl=d("textStroke"), textStrokeOnEl=d("textStrokeOn");
  const fontFamilyEl=d("fontFamily"), textAlignXEl=d("textAlignX"), textAlignYEl=d("textAlignY"), textOffXEl=d("textOffX"), textOffYEl=d("textOffY");
  const withTextEl=d("withText");

  // ====== helpers ======
  function toInt(el){ return parseInt(el.value,10)||0 }
  function tileRect(i){
    const COLS = toInt(colsEl), ROWS = toInt(rowsEl);
    const TILE_W=toInt(tileWEl), TILE_H=toInt(tileHEl), GAP=toInt(gapEl);
    const GRID_W = COLS*TILE_W + (COLS+1)*GAP;
    const GRID_H = ROWS*TILE_H + (ROWS+1)*GAP;
    const offx = (canvas.width - GRID_W)/2 + toInt(offXEl);
    const offy = (canvas.height - GRID_H)/2 + toInt(offYEl);
    const r = Math.floor(i/COLS), c = i % COLS;
    const x = offx + GAP + c*(TILE_W+GAP);
    const y = offy + GAP + r*(TILE_H+GAP);
    return {x,y,w:TILE_W,h:TILE_H}
  }
  function roundRectPath(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }
  async function fetchText(url){
    const cands = [];
    const user = (proxyInput.value||"").trim();
    const u = encodeURIComponent(url);
    if(user) cands.push(user + u);
    cands.push(url);
    cands.push("https://cors.isomorphic-git.org/" + url);
    for(const u2 of cands){
      try{
        const res = await fetch(u2,{cache:"no-store"});
        if(res.ok){ return await res.text() }
      }catch{}
    }
    throw new Error("fetch failed");
  }
  async function fetchBlob(url){
    const cands = [];
    const user = (proxyInput.value||"").trim();
    if(user) cands.push(user + encodeURIComponent(url));
    try{
      const u = new URL(url);
      cands.push(`https://images.weserv.nl/?url=${u.host}${u.pathname}${u.search}`);
    }catch{}
    cands.push("https://cors.isomorphic-git.org/" + url);
    cands.push(url);
    for(const u2 of cands){
      try{
        const res = await fetch(u2,{cache:"no-store"});
        if(!res.ok) continue;
        const b = await res.blob();
        if((b.type||"").startsWith("image/")) return b;
      }catch{}
    }
    throw new Error("image fetch failed");
  }
  async function getBitmap(url){
    if(imgCache.has(url)) return imgCache.get(url);
    const blob = await fetchBlob(url);
    const bmp = await createImageBitmap(blob);
    imgCache.set(url,bmp);
    return bmp;
  }
  function parseGViz(raw){
    // strip function wrapper
    const s = raw.substring(raw.indexOf("{"), raw.lastIndexOf("}")+1);
    const json = JSON.parse(s);
    const cols = json.table.cols.map(c=>c.label);
    const rows = json.table.rows;
    const idx = Object.fromEntries(cols.map((c,i)=>[c,i]));
    const data = [];
    for(const r of rows){
      const c=r.c;
      const cell = (k)=>{
        const i=idx[k]; if(i==null) return "";
        const obj=c[i]; if(!obj) return "";
        if(obj.f && /href\s*=/.test(obj.f)){
          const m = obj.f.match(/href\s*=\s*"([^"]+)"/i);
          if(m) return m[1];
        }
        return obj.v ?? "";
      };
      const item = {
        id: String(cell("Gift ID")||"").trim(),
        name: String(cell("Gift Name")||"").trim(),
        cost: Number(cell("Gift Cost")||0),
        imageUrl: String(cell("Gift Image URL")||"").trim()
      };
      if(item.id && item.name && item.imageUrl) data.push(item);
    }
    return data;
  }

  // ====== UI ======
  function renderList(){
    list.innerHTML="";
    for(const g of all){
      const b=document.createElement("div");
      b.className="item";
      b.innerHTML=`<b>${escapeHtml(g.name)}</b><span class="badge">🪙 ${g.cost}</span>`;
      b.onclick=()=>{ picked.push({...g, note:""}); renderSlots(); draw() };
      list.appendChild(b);
    }
  }
  function renderSlots(){
    const COLS=toInt(colsEl), ROWS=toInt(rowsEl);
    const total=COLS*ROWS;
    slots.innerHTML="";
    for(let i=0;i<total;i++){
      const g=picked[i];
      const div=document.createElement("div");
      div.className="slot";
      const cap=document.createElement("div");
      cap.className="cap"; cap.textContent=`スロット ${i+1}`;
      div.appendChild(cap);
      if(g){
        const row=document.createElement("div");
        row.className="row1";
        const img=document.createElement("img");
        // async load
        getBitmap(g.imageUrl).then(()=>draw()).catch(()=>{});
        img.src=g.imageUrl; // just placeholder thumbnail
        const nm=document.createElement("div");
        nm.className="name"; nm.textContent=`${g.name} / 🪙${g.cost}`;
        row.appendChild(img); row.appendChild(nm);
        div.appendChild(row);

        const input=document.createElement("input");
        input.type="text"; input.placeholder="このギフトに表示するテキスト（任意）";
        input.value=g.note||"";
        input.oninput=(e)=>{ picked[i].note=e.target.value; draw() };
        div.appendChild(input);

        const small=document.createElement("div");
        small.innerHTML=`<span class="note">${escapeHtml(g.id)}</span> <span style="float:right;cursor:pointer;color:#f87171" data-x>削除</span>`;
        small.querySelector("[data-x]").onclick=()=>{ picked.splice(i,1); renderSlots(); draw() };
        div.appendChild(small);
      }else{
        const p=document.createElement("div");
        p.className="note"; p.textContent="（未配置）"; div.appendChild(p);
      }
      slots.appendChild(div);
    }
  }
  function escapeHtml(s){ return String(s).replace(/[&<>\"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[m])) }

  // ====== drawing ======
  function resizeCanvas(){
    const W=bgSize.w, H=bgSize.h;
    canvas.width=W; canvas.height=H;
  }
  function clearCanvas(){
    ctx.fillStyle="#0b0f15"; ctx.fillRect(0,0,canvas.width,canvas.height);
    if(bgImage) ctx.drawImage(bgImage,0,0,canvas.width,canvas.height);
  }
  function draw(){
    resizeCanvas();
    clearCanvas();
    const COLS=toInt(colsEl), ROWS=toInt(rowsEl), TILE_W=toInt(tileWEl), TILE_H=toInt(tileHEl), GAP=toInt(gapEl);
    const R=toInt(radEl), PAD=toInt(iconPadEl), SCALE=toInt(iconScaleEl)/100;
    const withGuide = d("guide").value==="1";
    const allowOverflow = d("overflow").value==="1";
    iconScaleLabel.textContent=`現在: ${Math.round(SCALE*100)}%`;

    // grid
    for(let i=0;i<COLS*ROWS;i++){
      const r = tileRect(i);
      if(withGuide){
        ctx.strokeStyle="rgba(255,255,255,.08)";
        ctx.lineWidth=2;
        roundRectPath(r.x,r.y,r.w,r.h,R);
        ctx.stroke();
      }
      const g = picked[i];
      if(!g) continue;

      // image
      const maxW = r.w - PAD*2;
      const maxH = r.h - PAD*2;
      getBitmap(g.imageUrl).then(bmp=>{
        const ratio = Math.min(maxW/bmp.width, maxH/bmp.height) * (allowOverflow? Math.max(1,SCALE):SCALE);
        const iw=bmp.width*ratio, ih=bmp.height*ratio;
        const ix = r.x + (r.w - iw)/2;
        const iy = r.y + (r.h - ih)/2;
        ctx.drawImage(bmp, ix, iy, iw, ih);
      }).catch(()=>{});
    }

    // text overlay pass
    const drawText = withTextEl.checked || true; // always for preview; export will toggle
    if(drawText){
      ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.font=`${toInt(textSizeEl)}px ${fontFamilyEl.value}`;
      const color=textColorEl.value; const stroke=textStrokeEl.value; const strokeOn=textStrokeOnEl.checked;
      for(let i=0;i<COLS*ROWS;i++){
        const r=tileRect(i);
        const g=picked[i]; if(!g || !g.note) continue;
        // anchor
        let ax=textAlignXEl.value; let ay=textAlignYEl.value;
        let x = (ax==="left")? r.x+12 : (ax==="right")? r.x+r.w-12 : r.x+r.w/2;
        let y = (ay==="top")? r.y+12 : (ay==="bottom")? r.y+r.h-12 : r.y+r.h/2;
        x += toInt(textOffXEl); y += toInt(textOffYEl);
        ctx.font=`${toInt(textSizeEl)}px ${fontFamilyEl.value}`;
        ctx.textAlign = (ax==="left")?"left":(ax==="right")?"right":"center";
        ctx.textBaseline = (ay==="top")?"top":(ay==="bottom")?"bottom":"middle";
        if(strokeOn){ ctx.lineWidth=Math.max(4, Math.floor(toInt(textSizeEl)/16)); ctx.strokeStyle=stroke; ctx.strokeText(g.note, x, y) }
        ctx.fillStyle=color; ctx.fillText(g.note, x, y);
      }
    }
  }

  // ====== events ======
  document.getElementById("load").onclick = async ()=>{
    try{
      const base = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?gid=${GID}&tqx=out:json`;
      const raw = await fetchText(base);
      all = parseGViz(raw);
      renderList();
      renderSlots();
      draw();
    }catch(e){
      console.error(e); alert("シートの読み込みに失敗しました。権限とURLを確認してください。");
    }
  };
  ["change","input"].forEach(ev=>{
    [colsEl,rowsEl,tileWEl,tileHEl,gapEl,radEl,offXEl,offYEl,iconScaleEl,iconPadEl,overflowEl,guideEl,textSizeEl,textColorEl,textStrokeEl,textStrokeOnEl,fontFamilyEl,textAlignXEl,textAlignYEl,textOffXEl,textOffYEl,withTextEl].forEach(el=>{
      el.addEventListener(ev,()=>{ if(el===iconScaleEl){ iconScaleLabel.textContent=`現在: ${el.value}%`; } draw() })
    });
  });

  // background
  d("bgBtn").onclick=()=> d("bgFile").click();
  d("bgFile").onchange=async (e)=>{
    const f=e.target.files[0]; if(!f) return;
    try{
      const bmp = await createImageBitmap(f);
      bgImage = bmp; bgSize = {w:bmp.width,h:bmp.height}; draw();
    }catch{ alert("背景画像の読み込みに失敗しました"); }
  };

  // save PNG
  d("savePng").onclick=async ()=>{
    const includeText = withTextEl.checked;
    // redraw into an offscreen to honor includeText flag
    const off=document.createElement("canvas"); off.width=canvas.width; off.height=canvas.height;
    const c2=off.getContext("2d");
    // draw background
    c2.fillStyle="#0b0f15"; c2.fillRect(0,0,off.width,off.height);
    if(bgImage) c2.drawImage(bgImage,0,0,off.width,off.height);

    // draw images
    const COLS=toInt(colsEl), ROWS=toInt(rowsEl), TILE_W=toInt(tileWEl), TILE_H=toInt(tileHEl), GAP=toInt(gapEl);
    const R=toInt(radEl), PAD=toInt(iconPadEl), SCALE=toInt(iconScaleEl)/100;
    const allowOverflow = d("overflow").value==="1";
    function rr(x,y,w,h,r){ c2.beginPath(); c2.moveTo(x+r,y); c2.arcTo(x+w,y,x+w,y+h,r); c2.arcTo(x+w,y+h,x,y+h,r); c2.arcTo(x,y+h,x,y,r); c2.arcTo(x,y,x+w,y,r); c2.closePath() }
    function rect(i){
      const GRID_W = COLS*TILE_W + (COLS+1)*GAP;
      const GRID_H = ROWS*TILE_H + (ROWS+1)*GAP;
      const offx = (off.width - GRID_W)/2 + toInt(offXEl);
      const offy = (off.height - GRID_H)/2 + toInt(offYEl);
      const r = Math.floor(i/COLS), c = i % COLS;
      const x = offx + GAP + c*(TILE_W+GAP);
      const y = offy + GAP + r*(TILE_H+GAP);
      return {x,y,w:TILE_W,h:TILE_H}
    }
    // draw icons sequentially to ensure bitmaps resolved
    for(let i=0;i<COLS*ROWS;i++){
      const g=picked[i]; if(!g) continue;
      const r=rect(i);
      try{
        const bmp=await getBitmap(g.imageUrl);
        const maxW=r.w-PAD*2, maxH=r.h-PAD*2;
        const ratio=Math.min(maxW/bmp.width, maxH/bmp.height)*(allowOverflow?Math.max(1,SCALE):SCALE);
        const iw=bmp.width*ratio, ih=bmp.height*ratio;
        const ix=r.x+(r.w-iw)/2, iy=r.y+(r.h-ih)/2;
        c2.drawImage(bmp,ix,iy,iw,ih);
      }catch{}
    }

    if(includeText){
      c2.font=`${toInt(textSizeEl)}px ${fontFamilyEl.value}`;
      const color=textColorEl.value; const stroke=textStrokeEl.value; const strokeOn=textStrokeOnEl.checked;
      for(let i=0;i<COLS*ROWS;i++){
        const r=rect(i); const g=picked[i]; if(!g || !g.note) continue;
        let ax=textAlignXEl.value; let ay=textAlignYEl.value;
        let x=(ax==="left")? r.x+12 : (ax==="right")? r.x+r.w-12 : r.x+r.w/2;
        let y=(ay==="top")? r.y+12 : (ay==="bottom")? r.y+r.h-12 : r.y+r.h/2;
        x+=toInt(textOffXEl); y+=toInt(textOffYEl);
        c2.textAlign=(ax==="left")?"left":(ax==="right")?"right":"center";
        c2.textBaseline=(ay==="top")?"top":(ay==="bottom")?"bottom":"middle";
        if(strokeOn){ c2.lineWidth=Math.max(4,Math.floor(toInt(textSizeEl)/16)); c2.strokeStyle=stroke; c2.strokeText(g.note,x,y) }
        c2.fillStyle=color; c2.fillText(g.note,x,y);
      }
    }
    try{
      const url=off.toDataURL("image/png");
      const a=document.createElement("a"); a.href=url; a.download="gift_board.png"; a.click();
    }catch{ alert("PNG生成に失敗しました"); }
  };

  // ====== init ======
  function init(){
    bgSize={w:1280,h:720};
    resizeCanvas(); clearCanvas(); draw();
  }
  init();
})();
</script>
</body>
</html>
